"leetcode_1"	"<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>

<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>

<p>你可以按任意顺序返回答案。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,7,11,15], target = 9
<strong>输出：</strong>[0,1]
<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,2,4], target = 6
<strong>输出：</strong>[1,2]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,3], target = 6
<strong>输出：</strong>[0,1]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>2 <= nums.length <= 10<sup>4</sup></code></li>
    <li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>
    <li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>
    <li><strong>只会存在一个有效答案</strong></li>
</ul>

<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li></div></div><br><div><li>👍 13508</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int i = 0;
        while (i < nums.length) {
            int num = nums[i];
            if (map.containsKey(target - num)) {
                return new int[] { i, map.get(target - num) };
            } else {
                map.put(num, i);
            }
            i++;
        }
        return new int[] { -1, -1 };
    }
}
</xmp>"	"leetcode"
"leetcode_2"	"<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>

<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>

<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg"" style=""width: 483px; height: 342px;"" />
<pre>
<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]
<strong>输出：</strong>[7,0,8]
<strong>解释：</strong>342 + 465 = 807.
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>l1 = [0], l2 = [0]
<strong>输出：</strong>[0]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
<strong>输出：</strong>[8,9,9,9,0,0,0,1]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
    <li><code>0 <= Node.val <= 9</code></li>
    <li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<div><div>Related Topics</div><div><li>递归</li><li>链表</li><li>数学</li></div></div><br><div><li>👍 7408</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 设置dummyNode
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;

        // 这是逆序的
        ListNode lx = l1, ly = l2;
        int x = 0, y = 0, carry = 0, sum = 0;
        while (lx != null || ly != null) {
            x = lx == null ? 0 : lx.val;
            lx = lx == null ? null : lx.next;
            y = ly == null ? 0 : ly.val;
            ly = ly == null ? null : ly.next;
            sum = x + y + carry;

            carry = sum / 10;
            sum = sum % 10;
            cur.next = new ListNode(sum);
            cur = cur.next;
        }

        if (carry == 1) {
            cur.next = new ListNode(carry);
        }
        return dummy.next;
    }

}
</xmp>"	"leetcode"
"leetcode_3"	"<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串 </strong>的长度。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入: </strong>s = ""abcabcbb""
<strong>输出: </strong>3 
<strong>解释:</strong> 因为无重复字符的最长子串是 <code>""abc""，所以其</code>长度为 3。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入: </strong>s = ""bbbbb""
<strong>输出: </strong>1
<strong>解释: </strong>因为无重复字符的最长子串是 <code>""b""</code>，所以其长度为 1。
</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入: </strong>s = ""pwwkew""
<strong>输出: </strong>3
<strong>解释: </strong>因为无重复字符的最长子串是 <code>""wke""</code>，所以其长度为 3。
     请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>""pwke""</code> 是一个<em>子序列，</em>不是子串。
</pre>

<p><strong>示例 4:</strong></p>

<pre>
<strong>输入: </strong>s = """"
<strong>输出: </strong>0
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= s.length <= 5 * 10<sup>4</sup></code></li>
    <li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>字符串</li><li>滑动窗口</li></div></div><br><div><li>👍 6817</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0)
            return 0;
        HashSet<Character> set = new HashSet<>();
        int max = 0;
        int left = 0, right = 0; // 左右指针
        char[] chars = s.toCharArray();
        while (right < chars.length) {
            char c = chars[right];
            if (set.contains(c)) {
                // 如果发现当前字符已经存在，从left开始逐个往前删除
                set.remove(chars[left]);
                left++;
            } else {
                set.add(c);
                max = Math.max(max, right - left + 1);
                right++;
            }
        }

        return max;
    }
}
</xmp>"	"leetcode"
"leetcode_5"	"<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""babad""
<strong>输出：</strong>""bab""
<strong>解释：</strong>""aba"" 同样是符合题意的答案。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""cbbd""
<strong>输出：</strong>""bb""
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = ""a""
<strong>输出：</strong>""a""
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>s = ""ac""
<strong>输出：</strong>""a""
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= s.length <= 1000</code></li>
    <li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 4624</li><li>👎 0</li></div>"	"<xmp>class Solution {
    char[] chars = null;

    public String longestPalindrome(String s) {
        chars = s.toCharArray();
        int start = 0, end = 0;
        for (int i = 0; i < chars.length; i++) {
            int len1 = expandAroundCenter(i, i); // 以一个字符为中心向两边扩散，最终的长度是奇数
            int len2 = expandAroundCenter(i, i + 1); // 以二个字符为中心向两边扩散，最终的长度是偶数
            // 算出最长的长度
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    private int expandAroundCenter(int left, int right) {
        while (left >= 0 && right < chars.length && chars[left] == chars[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }

}
</xmp>"	"leetcode"
"leetcode_6"	"<p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>

<p>比如输入字符串为 <code>""PAYPALISHIRING""</code> 行数为 <code>3</code> 时，排列如下：</p>

<pre>
P   A   H   N
A P L S I I G
Y   I   R</pre>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>""PAHNAPLSIIGYIR""</code>。</p>

<p>请你实现这个将字符串进行指定行数变换的函数：</p>

<pre>
string convert(string s, int numRows);</pre>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""PAYPALISHIRING"", numRows = 3
<strong>输出：</strong>""PAHNAPLSIIGYIR""
</pre>
<strong>示例 2：</strong>

<pre>
<strong>输入：</strong>s = ""PAYPALISHIRING"", numRows = 4
<strong>输出：</strong>""PINALSIGYAHRPI""
<strong>解释：</strong>
P     I    N
A   L S  I G
Y A   H R
P     I
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = ""A"", numRows = 1
<strong>输出：</strong>""A""
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= s.length <= 1000</code></li>
    <li><code>s</code> 由英文字母（小写和大写）、<code>','</code> 和 <code>'.'</code> 组成</li>
    <li><code>1 <= numRows <= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li></div></div><br><div><li>👍 1463</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String convert(String s, int numRows) {
        if (numRows < 2)
            return s;
        // 初始化字符串
        List<StringBuilder> rows = new ArrayList<>();
        for (int i = 0; i < numRows; i++)
            rows.add(new StringBuilder());

        int i = 1, flag = -1;

        for (char c : s.toCharArray()) {
            rows.get(i - 1).append(c);
            // 反转方向
            if (i == 1 || i == numRows)
                flag = -flag;
            i += flag;
        }

        StringBuilder res = new StringBuilder();
        for (StringBuilder row : rows)
            res.append(row);
        return res.toString();
    }
}
</xmp>"	"leetcode"
"leetcode_7"	"<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>

<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，就返回 0。</p>
<strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>x = 123
<strong>输出：</strong>321
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>x = -123
<strong>输出：</strong>-321
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>x = 120
<strong>输出：</strong>21
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>x = 0
<strong>输出：</strong>0
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1</code></li>
</ul>
<div><div>Related Topics</div><div><li>数学</li></div></div><br><div><li>👍 3369</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public int reverse(int x) {
        int sum = 0, mod = 0;
        while (x != 0) {
            mod = x % 10;
            if (sum > Integer.MAX_VALUE / 10
                    || (sum == Integer.MAX_VALUE / 10 && mod > 7))
                // 判断上边界是否会溢出
                return 0;
            if (sum < Integer.MIN_VALUE / 10
                    || (sum == Integer.MIN_VALUE / 10 && mod < -8))
                // 判断下边界是否会溢出
                return 0;
            sum = sum * 10 + mod;
            x = x / 10;
        }
        return sum;
    }
}
</xmp>"	"leetcode"
"leetcode_8"	"<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>

<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>

<ul>
    <li>读入字符串并丢弃无用的前导空格</li>
    <li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
    <li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
    <li>将前面步骤读入的这些数字转换为整数（即，""123"" -> 123， ""0032"" -> 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
    <li>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被固定为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31 </sup>− 1</code> 的整数应该被固定为 <code>2<sup>31 </sup>− 1</code> 。</li>
    <li>返回整数作为最终结果。</li>
</ul>

<p><strong>注意：</strong></p>

<ul>
    <li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
    <li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""42""
<strong>输出：</strong>42
<strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步：""42""（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：""42""（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步：""<strong>42</strong>""（读入 ""42""）
           ^
解析得到整数 42 。
由于 ""42"" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 42 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""   -42""
<strong>输出：</strong>-42
<strong>解释：</strong>
第 1 步：""<strong>   </strong>-42""（读入前导空格，但忽视掉）
            ^
第 2 步：""   <strong>-</strong>42""（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步：""   -<strong>42</strong>""（读入 ""42""）
               ^
解析得到整数 -42 。
由于 ""-42"" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 -42 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = ""4193 with words""
<strong>输出：</strong>4193
<strong>解释：</strong>
第 1 步：""4193 with words""（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：""4193 with words""（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步：""<strong>4193</strong> with words""（读入 ""4193""；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 ""4193"" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 4193 。
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>s = ""words and 987""
<strong>输出：</strong>0
<strong>解释：</strong>
第 1 步：""words and 987""（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：""words and 987""（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步：""words and 987""（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 0 。</pre>

<p><strong>示例 5：</strong></p>

<pre>
<strong>输入：</strong>s = ""-91283472332""
<strong>输出：</strong>-2147483648
<strong>解释：</strong>
第 1 步：""-91283472332""（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：""<strong>-</strong>91283472332""（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步：""-<strong>91283472332</strong>""（读入 ""91283472332""）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 的下界，最终结果被截断为 -2<sup>31</sup> = -2147483648 。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= s.length <= 200</code></li>
    <li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li></div></div><br><div><li>👍 1336</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int myAtoi(String s) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_11"	"<p>给你 <code>n</code> 个非负整数 <code>a<sub>1</sub>，a<sub>2，</sub>...，a</code><sub><code>n</code>，</sub>每个数代表坐标中的一个点&nbsp;<code>(i,&nbsp;a<sub>i</sub>)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code>&nbsp;的两个端点分别为&nbsp;<code>(i,&nbsp;a<sub>i</sub>)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与&nbsp;<code>x</code>&nbsp;轴共同构成的容器可以容纳最多的水。</p>

<p><strong>说明：</strong>你不能倾斜容器。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"" style=""height: 287px; width: 600px;"" /></p>

<pre>
<strong>输入：</strong>[1,8,6,2,5,4,8,3,7]
<strong>输出：</strong>49 
<strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>height = [1,1]
<strong>输出：</strong>1
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>height = [4,3,2,1,4]
<strong>输出：</strong>16
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>height = [1,2,1]
<strong>输出：</strong>2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == height.length</code></li>
    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
    <li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>双指针</li></div></div><br><div><li>👍 3146</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int maxArea(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        while (left < right) {
            if (height[right] < height[left]) {
                ans = Math.max(ans, (right - left) * height[right]);
                right--;
            } else {
                ans = Math.max(ans, (right - left) * height[left]);
                left++;
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_12"	"<p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>

<pre>
<strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>

<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>

<ul>
    <li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
    <li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
    <li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>

<p>给你一个整数，将其转为罗马数字。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> num = 3
<strong>输出:</strong> ""III""</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> num = 4
<strong>输出:</strong> ""IV""</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> num = 9
<strong>输出:</strong> ""IX""</pre>

<p><strong>示例 4:</strong></p>

<pre>
<strong>输入:</strong> num = 58
<strong>输出:</strong> ""LVIII""
<strong>解释:</strong> L = 50, V = 5, III = 3.
</pre>

<p><strong>示例 5:</strong></p>

<pre>
<strong>输入:</strong> num = 1994
<strong>输出:</strong> ""MCMXCIV""
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= num <= 3999</code></li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>数学</li><li>字符串</li></div></div><br><div><li>👍 799</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int[] values = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
    String[] symbols = { ""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"",
            ""V"", ""IV"", ""I"" };

    public String intToRoman(int num) {
        StringBuffer ans = new StringBuffer();
        for (int i = 0; i < values.length; ++i) {
            int value = values[i];
            String symbol = symbols[i];
            while (num >= value) {
                num -= value;
                ans.append(symbol);
            }
            if (num == 0) {
                break;
            }
        }
        return ans.toString();
    }
}
</xmp>"	"leetcode"
"leetcode_15"	"<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>

<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]
<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>[]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= nums.length <= 3000</code></li>
    <li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 4243</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0)
                break; // 如果首个固定的数大于0，就直接退出，后面的两数相加，不肯能小于0
            if (i > 0 && nums[i] == nums[i - 1])
                continue; // 如果首个固定的数和前面的数相同，就说明已经计算过了
            int sum = 0;
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else {
                    if (sum == 0) {
                        // left > i + 1 就说明只有不相邻, 并且等于前一个
                        if (!(left > i + 1 && nums[left] == nums[left - 1])) {
                            ans.add(Arrays.asList(nums[i], nums[left],
                                    nums[right]));
                        }
                    }
                    left++;
                }
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_16"	"<p>给你一个长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code><em>&nbsp;</em>和 一个目标值&nbsp;<code>target</code>。请你从 <code>nums</code><em> </em>中选出三个整数，使它们的和与&nbsp;<code>target</code>&nbsp;最接近。</p>

<p>返回这三个数的和。</p>

<p>假定每组输入只存在恰好一个解。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [-1,2,1,-4], target = 1
<strong>输出：</strong>2
<strong>解释：</strong>与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,0,0], target = 1
<strong>输出：</strong>0
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>3 &lt;= nums.length &lt;= 1000</code></li>
    <li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
    <li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 1025</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int abs = Integer.MAX_VALUE;
        int ans = 0;
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            int left = i + 1, right = nums.length - 1;
            int sum = 0;
            while (left < right) {
                sum = nums[i] + nums[left] + nums[right];
                if (sum > target) {
                    if ((sum - target) < abs) {
                        abs = sum - target;
                        ans = sum;
                    }
                    right--;
                } else {
                    if (target - sum < abs) {
                        abs = target - sum;
                        ans = sum;
                    }
                    left++;
                }
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_18"	"<p>给你一个由 <code>n</code> 个整数组成的数组&nbsp;<code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组&nbsp;<code>[nums[a], nums[b], nums[c], nums[d]]</code>&nbsp;（若两个四元组元素一一对应，则认为两个四元组重复）：</p>

<ul>
    <li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>
    <li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
    <li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>

<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,0,-1,0,-2,2], target = 0
<strong>输出：</strong>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,2,2,2,2], target = 8
<strong>输出：</strong>[[2,2,2,2]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 200</code></li>
    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
    <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 1162</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        return null;
    }
}
</xmp>"	"leetcode"
"leetcode_19"	"<p>给你一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5], n = 2
<strong>输出：</strong>[1,2,3,5]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>head = [1], n = 1
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>head = [1,2], n = 1
<strong>输出：</strong>[1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中结点的数目为 <code>sz</code></li>
    <li><code>1 &lt;= sz &lt;= 30</code></li>
    <li><code>0 &lt;= Node.val &lt;= 100</code></li>
    <li><code>1 &lt;= n &lt;= sz</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<div><div>Related Topics</div><div><li>链表</li><li>双指针</li></div></div><br><div><li>👍 1777</li><li>👎 0</li></div>"	"<xmp>/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode cur = dummy;
        List<ListNode> list = new ArrayList<>();
        while (cur != null) {
            // 头节点是dummy
            list.add(cur);
            cur = cur.next;
        }
        ListNode pre = list.get(list.size() - n - 1);
        ListNode remove = list.get(list.size() - n);
        pre.next = remove.next;
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_21"	"<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"" style=""width: 662px; height: 302px;"" />
<pre>
<strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]
<strong>输出：</strong>[1,1,2,3,4,4]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>l1 = [], l2 = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>l1 = [], l2 = [0]
<strong>输出：</strong>[0]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
    <li><code>-100 <= Node.val <= 100</code></li>
    <li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<div><div>Related Topics</div><div><li>递归</li><li>链表</li></div></div><br><div><li>👍 2190</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy, p = list1, q = list2;
        while (p != null && q != null) {
            if (p.val <= q.val) {
                cur.next = p;
                p = p.next;
            } else {
                cur.next = q;
                q = q.next;
            }
            cur = cur.next;
        }
        if (p != null) {
            cur.next = p;
        } else if (q != null) {
            cur.next = q;
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_22"	"<p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 3
<strong>输出：</strong>[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>[""()""]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li><li>回溯</li></div></div><br><div><li>👍 2327</li><li>👎 0</li></div>"	"<xmp>class Solution {

    List<String> ans = new ArrayList<>();

    public List<String> generateParenthesis(int n) {
        backtrack(new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(StringBuilder cur, int open, int close, int max) {
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }
        if (open < max) {
            cur.append('(');
            backtrack(cur, open + 1, close, max);
            // 删除指定位置的字符
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(')');
            backtrack(cur, open, close + 1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
</xmp>"	"leetcode"
"leetcode_24"	"<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg"" style=""width: 422px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4]
<strong>输出：</strong>[2,1,4,3]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>head = [1]
<strong>输出：</strong>[1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
    <li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>递归</li><li>链表</li></div></div><br><div><li>👍 1230</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        return reverseKGroup(head, 2);
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(-1, head);
        ListNode g = dummy;
        ListNode cur = g.next;

        int i = 1;
        while (cur != null && i <= k) {
            cur = cur.next;
            if (i == k) {
                // 这里cur被重置，在下面的while循环中会恢复
                ListNode pre = null;
                cur = g.next;
                while (i >= 1) {
                    ListNode next = cur.next;
                    cur.next = pre;
                    pre = cur;
                    cur = next;
                    i--;
                }
                ListNode nextG = g.next;
                nextG.next = cur;
                g.next = pre;
                g = nextG;
            }
            i++;
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_25"	"<p>给你一个链表，每 <em>k </em>个节点一组进行翻转，请你返回翻转后的链表。</p>

<p><em>k </em>是一个正整数，它的值小于或等于链表的长度。</p>

<p>如果节点总数不是 <em>k </em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>

<p><strong>进阶：</strong></p>

<ul>
    <li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>
    <li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5], k = 2
<strong>输出：</strong>[2,1,4,3,5]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5], k = 3
<strong>输出：</strong>[3,2,1,4,5]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>head = [1,2,3,4,5], k = 1
<strong>输出：</strong>[1,2,3,4,5]
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>head = [1], k = 1
<strong>输出：</strong>[1]
</pre>

<ul>
</ul>

<p><strong>提示：</strong></p>

<ul>
    <li>列表中节点的数量在范围 <code>sz</code> 内</li>
    <li><code>1 <= sz <= 5000</code></li>
    <li><code>0 <= Node.val <= 1000</code></li>
    <li><code>1 <= k <= sz</code></li>
</ul>
<div><div>Related Topics</div><div><li>递归</li><li>链表</li></div></div><br><div><li>👍 1463</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(-1, head);
        ListNode g = dummy;
        ListNode cur = g.next;

        int i = 1;
        while (cur != null && i <= k) {
            cur = cur.next;
            if (i == k) {
                // 这里cur被重置，在下面的while循环中会恢复
                ListNode pre = null;
                cur = g.next;
                while (i >= 1) {
                    ListNode next = cur.next;
                    cur.next = pre;
                    pre = cur;
                    cur = next;
                    i--;
                }
                ListNode nextG = g.next;
                nextG.next = cur;
                g.next = pre;
                g = nextG;
            }
            i++;
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_29"	"<p>给定两个整数，被除数&nbsp;<code>dividend</code>&nbsp;和除数&nbsp;<code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>

<p>返回被除数&nbsp;<code>dividend</code>&nbsp;除以除数&nbsp;<code>divisor</code>&nbsp;得到的商。</p>

<p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code></p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1:</strong></p>

<pre><strong>输入:</strong> dividend = 10, divisor = 3
<strong>输出:</strong> 3
<strong>解释: </strong>10/3 = truncate(3.33333..) = truncate(3) = 3</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre><strong>输入:</strong> dividend = 7, divisor = -3
<strong>输出:</strong> -2
<strong>解释:</strong> 7/-3 = truncate(-2.33333..) = -2</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>被除数和除数均为 32 位有符号整数。</li>
    <li>除数不为&nbsp;0。</li>
    <li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]。本题中，如果除法结果溢出，则返回 2<sup>31&nbsp;</sup>&minus; 1。</li>
</ul>
<div><div>Related Topics</div><div><li>位运算</li><li>数学</li></div></div><br><div><li>👍 863</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int divide(int dividend, int divisor) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_31"	"<p>整数数组的一个 <strong>排列</strong>&nbsp; 就是将其所有成员以序列或线性顺序排列。</p>

<ul>
    <li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>

<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>

<ul>
    <li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
    <li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
    <li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>

<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>

<p>必须<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank""> 原地 </a></strong>修改，只允许使用额外常数空间。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[1,3,2]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,2,1]
<strong>输出：</strong>[1,2,3]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,5]
<strong>输出：</strong>[1,5,1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 100</code></li>
    <li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li></div></div><br><div><li>👍 1519</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public void nextPermutation(int[] $nums) {
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        boolean find = false;
        // 从后往前找到第一个不是升序的位置
        for (int i = length; i >= 2; i--) {
            if (nums[i] > nums[i - 1]) {
                // 找到比这个位置大的最小值， 然后交换
                for (int j = length; j >= i; j--) {
                    if (nums[j] > nums[i - 1]) { //找到最右边大于nums[i-1]的数，并交换
                        int tmp = nums[i - 1];
                        nums[i - 1] = nums[j];
                        nums[j] = tmp;
                        break;
                    }
                }
                // 将这个位置后面的数组倒序
                Arrays.sort(nums, i, length + 1); //将后面降序变为升序
                find = true;
                break;
            }
        }

        if (!find) {
            // 如果前面没找到，说明已经是最大值

            Arrays.sort(nums);
        }

        System.arraycopy(nums, 1, $nums, 0, length);
    }
}
</xmp>"	"leetcode"
"leetcode_33"	"<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>

<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 <= k < nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>

<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0
<strong>输出：</strong>4
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3
<strong>输出：</strong>-1</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1], target = 0
<strong>输出：</strong>-1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 5000</code></li>
    <li><code>-10^4 <= nums[i] <= 10^4</code></li>
    <li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
    <li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
    <li><code>-10^4 <= target <= 10^4</code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li></div></div><br><div><li>👍 1822</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int search(int[] nums, int target) {
        int lo = 0, hi = nums.length - 1, mid = 0;

        while (lo < hi) {
            mid = lo + (hi - lo) / 2;
            if (nums[mid] == target) {
                lo = mid;
                break;
            }
            // 先根据 nums[mid] 与 nums[lo] 的关系判断 mid 是在左段还是右段
            if (nums[mid] >= nums[lo]) {
                // 再判断 target 是在 mid 的左边还是右边，从而调整左右边界 lo 和 hi
                if (target >= nums[lo] && target < nums[mid]) {
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }
            } else {
                if (target > nums[mid] && target <= nums[hi]) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
        }

        return nums[lo] == target ? lo : -1;
    }
}
</xmp>"	"leetcode"
"leetcode_34"	"<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>

<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>

<p><strong>进阶：</strong></p>

<ul>
    <li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8
<strong>输出：</strong>[3,4]</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6
<strong>输出：</strong>[-1,-1]</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [], target = 0
<strong>输出：</strong>[-1,-1]</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= nums.length <= 10<sup>5</sup></code></li>
    <li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>
    <li><code>nums</code> 是一个非递减数组</li>
    <li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li></div></div><br><div><li>👍 1438</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int[] nums;
    int n;
    int target;

    public int[] searchRange(int[] nums, int target) {
        int[] ans = new int[] { -1, -1 };
        if (nums == null || nums.length == 0)
            return ans;

        this.nums = nums;
        this.target = target;
        n = nums.length;

        ans[0] = findFirst();
        if (ans[0] == -1)
            return ans;
        ans[1] = findLast();
        return ans;
    }

    //寻找左边界
    private int findFirst() {
        int left = 0, right = n - 1;
        while (left < right) {
            // 取下限制
            int mid = (left + right) / 2;
            if (target <= nums[mid])
                right = mid;
            else
                left = mid + 1;
        }
        return nums[left] == target ? left : -1;
    }

    //寻找右边界
    private int findLast() {
        int left = 0, right = n - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (target >= nums[mid])
                left = mid;
            else
                right = mid - 1;
        }
        return nums[left] == target ? left : -1;

    }
}
</xmp>"	"leetcode"
"leetcode_36"	"<p>请你判断一个&nbsp;<code>9 x 9</code> 的数独是否有效。只需要<strong> 根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>

<ol>
    <li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>
    <li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>
    <li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li>
</ol>

<p>&nbsp;</p>

<p><strong>注意：</strong></p>

<ul>
    <li>一个有效的数独（部分已被填充）不一定是可解的。</li>
    <li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
    <li>空白格用&nbsp;<code>'.'</code>&nbsp;表示。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png"" style=""height:250px; width:250px"" />
<pre>
<strong>输入：</strong>board = 
[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>board = 
[[""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
<strong>输出：</strong>false
<strong>解释：</strong>除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>board.length == 9</code></li>
    <li><code>board[i].length == 9</code></li>
    <li><code>board[i][j]</code> 是一位数字（<code>1-9</code>）或者 <code>'.'</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>矩阵</li></div></div><br><div><li>👍 778</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 9;
    Map<Character, Boolean> map = new HashMap<>();

    public boolean isValidSudoku(char[][] board) {
        // 校验每行
        for (int i = 0; i < length; i++) {
            map.clear();
            for (int j = 0; j < length; j++) {
                if (board[i][j] == '.')
                    continue;
                if (map.containsKey(board[i][j])) {
                    return false;
                } else {
                    map.put(board[i][j], true);
                }
            }
        }

        // 校验每列
        for (int i = 0; i < length; i++) {
            map.clear();
            for (int j = 0; j < length; j++) {
                if (board[j][i] == '.')
                    continue;
                if (map.containsKey(board[j][i])) {
                    return false;
                } else {
                    map.put(board[j][i], true);
                }
            }
        }

        // 九宫格
        for (int i = 0; i < length; i += 3) {
            for (int j = 0; j < length; j += 3) {
                map.clear();
                for (int k = i; k < i + 3; k++) {
                    for (int l = j; l < j + 3; l++) {
                        if (board[k][l] == '.')
                            continue;
                        if (map.containsKey(board[k][l])) {
                            return false;
                        } else {
                            map.put(board[k][l], true);
                        }
                    }
                }
            }
        }

        return true;
    }
}
</xmp>"	"leetcode"
"leetcode_39"	"<p>给你一个 <strong>无重复元素</strong> 的整数数组&nbsp;<code>candidates</code> 和一个目标整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中可以使数字和为目标数&nbsp;<code>target</code> 的 <em>所有&nbsp;</em><strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>

<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。&nbsp;</p>

<p>对于给定的输入，保证和为&nbsp;<code>target</code> 的不同组合数少于 <code>150</code> 个。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1：</strong></p>

<pre>
<strong>输入：</strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code>
<strong>输出：</strong>[[2,2,3],[7]]
<strong>解释：</strong>
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入: </strong>candidates = [2,3,5]<code>, </code>target = 8
<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入: </strong>candidates = <code>[2], </code>target = 1
<strong>输出: </strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= candidates.length &lt;= 30</code></li>
    <li><code>1 &lt;= candidates[i] &lt;= 200</code></li>
    <li><code>candidate</code> 中的每个元素都 <strong>互不相同</strong></li>
    <li><code>1 &lt;= target &lt;= 500</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>回溯</li></div></div><br><div><li>👍 1742</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int target = 0;
    int length = 0;
    int[] nums = null;
    int sum = 0;
    int i = 0;
    LinkedList<Integer> ss = new LinkedList<>();
    LinkedList<Integer> cs = new LinkedList<>();
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        this.length = candidates.length;
        this.nums = candidates;
        this.target = target;

        push();
        while (!cs.isEmpty()) {
            Integer c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                i = c;
                sum = sum + nums[c];
                push();
            } else {
                if (sum == target) {
                    add();
                }
                ss.pop();
                cs.pop();
                sum = sum - nums[c];
            }
        }

        return ans;
    }

    void push() {
        for (int j = i; j < length; j++) {
            if (sum + nums[j] <= target) {
                cs.push(new Integer(j));
            }
        }
    }

    void add() {
        List<Integer> tl = new ArrayList<>();
        for (int i = ss.size() - 1; i >= 0; i--) {
            tl.add(nums[ss.get(i)]);
        }
        ans.add(tl);
    }
}
</xmp>"	"leetcode"
"leetcode_40"	"<p>给定一个候选人编号的集合&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>

<p><code>candidates</code>&nbsp;中的每个数字在每个组合中只能使用&nbsp;<strong>一次</strong>&nbsp;。</p>

<p><strong>注意：</strong>解集不能包含重复的组合。&nbsp;</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1:</strong></p>

<pre>
<strong>输入:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,
<strong>输出:</strong>
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>
<strong>输入:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,
<strong>输出:</strong>
[
[1,2,2],
[5]
]</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>
    <li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>
    <li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>回溯</li></div></div><br><div><li>👍 829</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    int target = 0;
    int sum = 0;
    int i = 0;
    LinkedList<Integer> ss = new LinkedList<>();
    LinkedList<Integer> cs = new LinkedList<>();

    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        this.length = candidates.length;
        this.nums = candidates;
        this.target = target;

        Arrays.sort(candidates);

        push();
        while (!cs.isEmpty()) {
            Integer c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                sum = sum + nums[c];
                i = c + 1;
                push();
            } else {
                if (sum == target) {
                    add();
                }
                cs.pop();
                ss.pop();
                sum = sum - nums[c];
            }
        }
        return ans;
    }

    void push() {
        int j = i;
        int last = 0;
        while (j < length) {
            if (sum + nums[j] <= target && nums[j] != last) {
                cs.push(j);
                last = nums[j];
            }
            j++;
        }
    }

    void add() {
        List<Integer> tl = new ArrayList<>();
        for (int j = ss.size() - 1; j >= 0; j--) {
            tl.add(nums[ss.get(j)]);
        }
        ans.add(tl);
    }

}
</xmp>"	"leetcode"
"leetcode_43"	"<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>

<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> num1 = ""2"", num2 = ""3""
<strong>输出:</strong> ""6""</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>
<strong>输入:</strong> num1 = ""123"", num2 = ""456""
<strong>输出:</strong> ""56088""</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>
    <li><code>num1</code>&nbsp;和 <code>num2</code>&nbsp;只能由数字组成。</li>
    <li><code>num1</code>&nbsp;和 <code>num2</code>&nbsp;都不包含任何前导零，除了数字0本身。</li>
</ul>
<div><div>Related Topics</div><div><li>数学</li><li>字符串</li><li>模拟</li></div></div><br><div><li>👍 828</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals(""0"") || num2.equals(""0"")) {
            return ""0"";
        }
        // 保存计算结果
        String res = ""0"";

        // num2 逐位与 num1 相乘
        for (int i = num2.length() - 1; i >= 0; i--) {
            int carry = 0;
            // 保存 num2 第i位数字与 num1 相乘的结果
            StringBuilder temp = new StringBuilder();
            // 补 0
            for (int j = 0; j < num2.length() - 1 - i; j++) {
                temp.append(0);
            }
            int n2 = num2.charAt(i) - '0';

            // num2 的第 i 位数字 n2 与 num1 相乘
            for (int j = num1.length() - 1; j >= 0 || carry != 0; j--) {
                int n1 = j < 0 ? 0 : num1.charAt(j) - '0';
                int product = (n1 * n2 + carry) % 10;
                temp.append(product);
                carry = (n1 * n2 + carry) / 10;
            }
            // 将当前结果与新计算的结果求和作为新的结果
            res = addStrings(res, temp.reverse().toString());
        }
        return res;
    }

    /**
     * 对两个字符串数字进行相加，返回字符串形式的和
     */
    public String addStrings(String num1, String num2) {
        StringBuilder builder = new StringBuilder();
        int carry = 0;
        for (int i = num1.length() - 1, j = num2.length() - 1; i >= 0 || j >= 0
                || carry != 0; i--, j--) {
            int x = i < 0 ? 0 : num1.charAt(i) - '0';
            int y = j < 0 ? 0 : num2.charAt(j) - '0';
            int sum = (x + y + carry) % 10;
            builder.append(sum);
            carry = (x + y + carry) / 10;
        }
        return builder.reverse().toString();
    }
}
</xmp>"	"leetcode"
"leetcode_45"	"<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。</p>

<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>

<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>

<p>假设你总是可以到达数组的最后一个位置。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> nums = [2,3,1,1,4]
<strong>输出:</strong> 2
<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。
     从下标为 0 跳到下标为 1 的位置，跳 <code>1</code> 步，然后跳 <code>3</code> 步到达数组的最后一个位置。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> nums = [2,3,0,1,4]
<strong>输出:</strong> 2
</pre>

<p> </p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 <= nums.length <= 10<sup>4</sup></code></li>
    <li><code>0 <= nums[i] <= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1387</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int jump(int[] $nums) {
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);
        int i = 1, max = 1, count = 0;

        while (max < length) {
            int nextMax = max;
            while (i <= length && i <= max) {
                nextMax = Math.max(i + nums[i], nextMax);
                i++;
            }
            max = nextMax;
            count++;
        }
        return count;
    }
}
</xmp>"	"leetcode"
"leetcode_46"	"<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,1]
<strong>输出：</strong>[[0,1],[1,0]]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1]
<strong>输出：</strong>[[1]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 6</code></li>
    <li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
    <li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>回溯</li></div></div><br><div><li>👍 1742</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    int count = 0;
    boolean[] used = null;
    LinkedList<Integer> cs = new LinkedList<>();
    LinkedList<Integer> ss = new LinkedList<>();

    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        Arrays.sort(nums);
        this.length = nums.length;
        this.nums = nums;
        used = new boolean[length];

        push();
        while (!cs.isEmpty()) {
            Integer c = cs.peek();
            if (ss.peek() != c) {
                // 方法进入
                ss.push(c);
                used[c] = true;
                count++;
                push();
            } else {
                // 方法退出
                if (count == length) {
                    add();
                }
                ss.pop();
                cs.pop();
                used[c] = false;
                count--;
            }
        }
        return ans;
    }

    void push() {
        int i = 0;
        while (i < length) {
            if (!used[i]) {
                cs.push(i);
            }
            i++;
        }
    }

    void add() {
        List<Integer> tl = new ArrayList<>();
        for (int i = ss.size() - 1; i >= 0; i--) {
            tl.add(nums[ss.get(i)]);
        }
        ans.add(tl);
    }

}
</xmp>"	"leetcode"
"leetcode_47"	"<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,2]
<strong>输出：</strong>
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 8</code></li>
    <li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>回溯</li></div></div><br><div><li>👍 940</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    int count = 0;
    boolean used[] = null;
    LinkedList<Integer> cs = new LinkedList<>();
    LinkedList<Integer> ss = new LinkedList<>();

    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] $nums) {
        Arrays.sort($nums);
        length = $nums.length;
        nums = new int[length + 1];
        used = new boolean[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);
        nums[0] = Integer.MIN_VALUE;

        push();
        while (!cs.isEmpty()) {
            Integer c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                // 连续的都设置为used
                used[c] = true;
                count++;
                push();
            } else {
                if (count == length) {
                    add();
                }
                cs.pop();
                ss.pop();
                // 连续的都设置为used
                used[c] = false;
                count--;
            }
        }

        return ans;
    }

    void push() {
        int i = 1;
        while (i <= length) {
            if (!used[i] && !(!used[i - 1] && nums[i] == nums[i - 1])) {
                cs.push(i);
            }
            i++;
        }
    }

    void add() {
        List<Integer> tl = new ArrayList<>();
        for (int i = ss.size() - 1; i >= 0; i--) {
            tl.add(nums[ss.get(i)]);
        }
        ans.add(tl);
    }

}
</xmp>"	"leetcode"
"leetcode_48"	"<p>给定一个 <em>n&nbsp;</em>×&nbsp;<em>n</em> 的二维矩阵&nbsp;<code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>

<p>你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank""> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要 </strong>使用另一个矩阵来旋转图像。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"" style=""height: 188px; width: 500px;"" />
<pre>
<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"" style=""height: 201px; width: 500px;"" />
<pre>
<strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == matrix.length == matrix[i].length</code></li>
    <li><code>1 &lt;= n &lt;= 20</code></li>
    <li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<div><div>Related Topics</div><div><li>数组</li><li>数学</li><li>矩阵</li></div></div><br><div><li>👍 1157</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length - 1;
        int t = 0, l = 0, r = n, b = n;

        while (true) {

            int[] temp = new int[r - l];

            // 将上面一行移出
            for (int i = l; i < r; i++) {
                temp[i - l] = matrix[t][i];
            }

            for (int i = b; i > t; i--) {
                matrix[t][n - i] = matrix[i][l];
            }

            for (int i = r; i > l; i--) {
                matrix[i][l] = matrix[b][i];
            }

            for (int i = t; i < b; i++) {
                matrix[b][n - i] = matrix[i][r];
            }

            for (int i = l; i < r; i++) {
                matrix[i][r] = temp[i - l];
            }

            t++;
            l++;
            r--;
            b--;

            if (t > b)
                break;
        }
    }
}
</xmp>"	"leetcode"
"leetcode_49"	"<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>

<p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> strs = <code>[""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""]</code>
<strong>输出: </strong>[[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> strs = <code>[""""]</code>
<strong>输出: </strong>[[""""]]
</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> strs = <code>[""a""]</code>
<strong>输出: </strong>[[""a""]]</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>
    <li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
    <li><code>strs[i]</code>&nbsp;仅包含小写字母</li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>字符串</li><li>排序</li></div></div><br><div><li>👍 1002</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> group = Arrays.stream(strs).collect(
                Collectors.groupingBy(str -> {
                    // 返回 str 排序后的结果。
                    // 按排序后的结果来grouping by，算子类似于 sql 里的 group by。
                        char[] array = str.toCharArray();
                        Arrays.sort(array);
                        return new String(array);
                    }));

        return new ArrayList<>(group.values());
    }
}
</xmp>"	"leetcode"
"leetcode_50"	"<p>实现&nbsp;<a href=""https://www.cplusplus.com/reference/valarray/pow/"" target=""_blank"">pow(<em>x</em>, <em>n</em>)</a>&nbsp;，即计算 <code>x</code> 的 <code>n</code> 次幂函数（即，<code>x<sup>n</sup></code><sup><span style=""font-size:10.8333px""> </span></sup>）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>x = 2.00000, n = 10
<strong>输出：</strong>1024.00000
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>x = 2.10000, n = 3
<strong>输出：</strong>9.26100
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>x = 2.00000, n = -2
<strong>输出：</strong>0.25000
<strong>解释：</strong>2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>-100.0 &lt; x &lt; 100.0</code></li>
    <li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>
    <li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>递归</li><li>数学</li></div></div><br><div><li>👍 904</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public double myPow(double x, int n) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_54"	"<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg"" style=""width: 242px; height: 242px;"" />
<pre>
<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg"" style=""width: 322px; height: 242px;"" />
<pre>
<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == matrix.length</code></li>
    <li><code>n == matrix[i].length</code></li>
    <li><code>1 <= m, n <= 10</code></li>
    <li><code>-100 <= matrix[i][j] <= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>矩阵</li><li>模拟</li></div></div><br><div><li>👍 976</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new ArrayList<>();
        int left = 1, right = matrix[0].length;
        int top = 1, down = matrix.length;

        while (true) {
            // 上边界：从左到右扫描
            for (int i = left; i <= right; i++) {
                ans.add(matrix[top - 1][i - 1]);
            }
            // 上边界向下移动
            top++;
            if (top > down)
                break;

            // 右边界：从上往下扫描
            for (int i = top; i <= down; i++) {
                ans.add(matrix[i - 1][right - 1]);
            }
            // 右边界向左移动
            right--;
            if (left > right)
                break;

            // 下边界：从右往左扫描
            for (int i = right; i >= left; i--) {
                ans.add(matrix[down - 1][i - 1]);
            }
            // 下边界上移
            down--;
            if (top > down)
                break;

            // 左边界：从下往上扫描
            for (int i = down; i >= top; i--) {
                ans.add(matrix[i - 1][left - 1]);
            }
            // 左边界向右移动
            left++;
            if (left > right)
                break;

        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_55"	"<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>

<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>

<p>判断你是否能够到达最后一个下标。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,3,1,1,4]
<strong>输出：</strong>true
<strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,2,1,0,4]
<strong>输出：</strong>false
<strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>
    <li><code>0 <= nums[i] <= 10<sup>5</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1627</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public boolean canJump(int[] $nums) {
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        int i = 1, max = 1;

        while (max < length) {
            int nextMax = max;
            while (i <= length && i <= max) {
                nextMax = Math.max(i + nums[i], nextMax);
                i++;
            }

            if (nextMax == max) {
                return false;
            } else {
                max = nextMax;
            }
        }

        return true;
    }
}
</xmp>"	"leetcode"
"leetcode_56"	"<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回&nbsp;<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]
<strong>输出：</strong>[[1,6],[8,10],[15,18]]
<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入：</strong>intervals = [[1,4],[4,5]]
<strong>输出：</strong>[[1,5]]
<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>
    <li><code>intervals[i].length == 2</code></li>
    <li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>排序</li></div></div><br><div><li>👍 1284</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public int[][] merge(int[][] intervals) {
        List<int[]> list = new ArrayList<>();
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Integer.compare(o1[0], o2[0]);
            }
        });

        int i = 0;
        int length = intervals.length;
        while (i < length) {
            int[] t = new int[2];
            int start = intervals[i][0];
            int end = intervals[i][1];
            while (i < length - 1 && end >= intervals[i + 1][0]) {
                // 在这里控制条件
                end = Math.max(end, intervals[i + 1][1]);
                i++;
            }
            t[0] = start;
            t[1] = end;
            list.add(t);
            i++;
        }

        int[][] ans = new int[list.size()][];
        for (int j = 0; j < list.size(); j++) {
            ans[j] = list.get(j);
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_59"	"<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n<sup>2</sup></code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"" style=""width: 242px; height: 242px;"" />
<pre>
<strong>输入：</strong>n = 3
<strong>输出：</strong>[[1,2,3],[8,9,4],[7,6,5]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>[[1]]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= n <= 20</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>矩阵</li><li>模拟</li></div></div><br><div><li>👍 590</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int[][] generateMatrix(int n) {
        int t = 0, l = 0, r = n - 1, b = n - 1;
        int[][] mat = new int[n][n];
        int num = 1;
        while (true) {

            for (int i = l; i <= r; i++)
                mat[t][i] = num++; // left to right.
            t++;
            if (t > b)
                break;

            for (int i = t; i <= b; i++)
                mat[i][r] = num++; // top to bottom.
            r--;
            if (l > r)
                break;

            for (int i = r; i >= l; i--)
                mat[b][i] = num++; // right to left.
            b--;
            if (t > b)
                break;

            for (int i = b; i >= t; i--)
                mat[i][l] = num++; // bottom to top.
            l++;
            if (l > r)
                break;
        }
        return mat;
    }
}
</xmp>"	"leetcode"
"leetcode_62"	"<p>一个机器人位于一个 <code>m x n</code><em> </em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p>

<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>

<p>问总共有多少条不同的路径？</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img src=""https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"" />
<pre>
<strong>输入：</strong>m = 3, n = 7
<strong>输出：</strong>28</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>m = 3, n = 2
<strong>输出：</strong>3
<strong>解释：</strong>
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>m = 7, n = 3
<strong>输出：</strong>28
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>m = 3, n = 3
<strong>输出：</strong>6</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= m, n <= 100</code></li>
    <li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数学</li><li>动态规划</li><li>组合数学</li></div></div><br><div><li>👍 1272</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int uniquePaths(int m, int n) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_64"	"<p>给定一个包含非负整数的 <code><em>m</em> x <em>n</em></code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>

<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg"" style=""width: 242px; height: 242px;"" />
<pre>
<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]
<strong>输出：</strong>7
<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]
<strong>输出：</strong>12
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == grid.length</code></li>
    <li><code>n == grid[i].length</code></li>
    <li><code>1 <= m, n <= 200</code></li>
    <li><code>0 <= grid[i][j] <= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li><li>矩阵</li></div></div><br><div><li>👍 1132</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int minPathSum(int[][] grid) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_71"	"<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>

<p class=""MachineTrans-lang-zh-CN"">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>

<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>

<ul>
    <li>始终以斜杠 <code>'/'</code> 开头。</li>
    <li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>
    <li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>
    <li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>
</ul>

<p>返回简化后得到的 <strong>规范路径</strong> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>path = ""/home/""
<strong>输出：</strong>""/home""
<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>path = ""/../""
<strong>输出：</strong>""/""
<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>path = ""/home//foo/""
<strong>输出：</strong>""/home/foo""
<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>path = ""/a/./b/../../c/""
<strong>输出：</strong>""/c""
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= path.length <= 3000</code></li>
    <li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>
    <li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>
</ul>
<div><div>Related Topics</div><div><li>栈</li><li>字符串</li></div></div><br><div><li>👍 446</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String simplifyPath(String path) {
        LinkedList<String> d = new LinkedList<>();
        int n = path.length();
        int i = 0;
        while (i < n) {
            if (path.charAt(i) == '/') {
                i++;
                continue;
            }
            int j = i + 1;
            while (j < n && path.charAt(j) != '/')
                j++;
            String item = path.substring(i, j);
            if (item.equals("".."")) {
                if (!d.isEmpty())
                    d.pop();
            } else if (!item.equals(""."")) {
                d.push(item);
            }
            i = j;
        }

        StringBuilder sb = new StringBuilder();
        while (!d.isEmpty())
            sb.append(""/"" + d.pollLast());
        return sb.length() == 0 ? ""/"" : sb.toString();
    }
}
</xmp>"	"leetcode"
"leetcode_73"	"<p>给定一个&nbsp;<code><em>m</em> x <em>n</em></code> 的矩阵，如果一个元素为 <strong>0 </strong>，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href=""http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong> 算法<strong>。</strong></p>

<ul>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg"" style=""width: 450px; height: 169px;"" />
<pre>
<strong>输入：</strong>matrix = [[1,1,1],[1,0,1],[1,1,1]]
<strong>输出：</strong>[[1,0,1],[0,0,0],[1,0,1]]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg"" style=""width: 450px; height: 137px;"" />
<pre>
<strong>输入：</strong>matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
<strong>输出：</strong>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == matrix.length</code></li>
    <li><code>n == matrix[0].length</code></li>
    <li><code>1 &lt;= m, n &lt;= 200</code></li>
    <li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong></p>

<ul>
    <li>一个直观的解决方案是使用 &nbsp;<code>O(<em>m</em><em>n</em>)</code>&nbsp;的额外空间，但这并不是一个好的解决方案。</li>
    <li>一个简单的改进方案是使用 <code>O(<em>m</em>&nbsp;+&nbsp;<em>n</em>)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
    <li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>矩阵</li></div></div><br><div><li>👍 657</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int m, n;

    public void setZeroes(int[][] matrix) {
        m = matrix.length;
        n = matrix[0].length;

        boolean[] rowZero = new boolean[m];
        boolean[] colZero = new boolean[n];
        int row = matrix.length;
        int col = matrix[0].length;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 0) {
                    rowZero[i] = true;
                    colZero[j] = true;
                }
            }
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (rowZero[i] || colZero[j])
                    matrix[i][j] = 0;
            }
        }
    }
}
</xmp>"	"leetcode"
"leetcode_75"	"<p>给定一个包含红色、白色和蓝色、共&nbsp;<code>n</code><em> </em>个元素的数组<meta charset=""UTF-8"" />&nbsp;<code>nums</code>&nbsp;，<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>

<p>我们使用整数 <code>0</code>、&nbsp;<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>

<ul>
</ul>

<p>必须在不使用库的sort函数的情况下解决这个问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,0,2,1,1,0]
<strong>输出：</strong>[0,0,1,1,2,2]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,0,1]
<strong>输出：</strong>[0,1,2]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == nums.length</code></li>
    <li><code>1 &lt;= n &lt;= 300</code></li>
    <li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong></p>

<ul>
    <li>你可以不使用代码库中的排序函数来解决这道题吗？</li>
    <li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 1162</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public void sortColors(int[] nums) {
        int length = nums.length;
        int l = 0, r = length - 1;

        int count0 = 0;
        int count1 = 0;

        int temp = 0;

        while (l < r) {
            while (l <= length - 1 && nums[l] != 2) {
                if (nums[l] == 0) {
                    count0++;
                } else {
                    count1++;
                }
                nums[l] = 0;
                l++;
            }

            while (r >= 0 && nums[r] == 2) {
                r--;
            }

            // 交换
            if (l < r) {
                temp = nums[l];
                nums[l] = nums[r];
                nums[r] = temp;
            }
        }

        for (int i = count0; i < count0 + count1; i++) {
            nums[i] = 1;
        }

    }
}
</xmp>"	"leetcode"
"leetcode_78"	"<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>

<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>[[],[0]]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 10</code></li>
    <li><code>-10 <= nums[i] <= 10</code></li>
    <li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<div><div>Related Topics</div><div><li>位运算</li><li>数组</li><li>回溯</li></div></div><br><div><li>👍 1480</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    int i = 0;
    LinkedList<Integer> cs = new LinkedList<>();
    LinkedList<Integer> ss = new LinkedList<>();
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {

        this.length = nums.length;
        this.nums = nums;

        push();
        ans.add(Collections.emptyList());
        while (!cs.isEmpty()) {
            Integer c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                addAns();
                i = c;
                push();
            } else {
                ss.pop();
                cs.pop();
            }
        }

        return ans;
    }

    void push() {
        int j = i;
        while (j++ < length) {
            cs.push(j);
        }
    }

    void addAns() {
        List<Integer> tempList = new ArrayList<>();
        for (int j = ss.size() - 1; j >= 0; j--) {
            tempList.add(nums[ss.get(j) - 1]);
        }
        ans.add(tempList);
    }
}
</xmp>"	"leetcode"
"leetcode_79"	"<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/04/word2.jpg"" style=""width: 322px; height: 242px;"" />
<pre>
<strong>输入：</strong>board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg"" style=""width: 322px; height: 242px;"" />
<pre>
<strong>输入：</strong>board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""SEE""
<strong>输出：</strong>true
</pre>

<p><strong>示例 3：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/15/word3.jpg"" style=""width: 322px; height: 242px;"" />
<pre>
<strong>输入：</strong>board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCB""
<strong>输出：</strong>false
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == board.length</code></li>
    <li><code>n = board[i].length</code></li>
    <li><code>1 <= m, n <= 6</code></li>
    <li><code>1 <= word.length <= 15</code></li>
    <li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>

<p> </p>

<p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>
<div><div>Related Topics</div><div><li>数组</li><li>回溯</li><li>矩阵</li></div></div><br><div><li>👍 1188</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int rl = 0, cl = 0;
    boolean[][] used = null;
    char[][] board = null;
    int wl = 0;
    char[] word;

    int r = -1, c = -1, wi = 0;
    LinkedList<int[]> ss = new LinkedList<>();
    LinkedList<int[]> cs = new LinkedList<>();

    public boolean exist(char[][] $board, String $word) {
        rl = $board.length;
        cl = $board[0].length;
        board = $board;
        used = new boolean[rl][cl];
        word = $word.toCharArray();
        wl = word.length;

        push();
        while (!cs.isEmpty()) {
            int[] ca = cs.peek();

            if (ss.peek() != ca) {
                ss.push(ca);
                r = ca[0];
                c = ca[1];
                used[ca[0]][ca[1]] = true;
                wi++;
                push();
            } else {
                if (wi == wl) {
                    return true;
                }
                ss.pop();
                cs.pop();
                used[ca[0]][ca[1]] = false;
                wi--;
            }
        }

        return false;
    }

    void push() {
        if (r == -1 && c == -1) {
            for (int i = 0; i < rl; i++) {
                for (int j = 0; j < cl; j++) {
                    if (board[i][j] == word[wi]) {
                        cs.push(new int[] { i, j });
                    }
                }
            }
        } else {
            // 左右剪值
            for (int i = c - 1; i <= c + 1; i++) {
                if (i >= 0 && i < cl && !used[r][i] && wi < wl
                        && board[r][i] == word[wi]) {
                    cs.push(new int[] { r, i });
                }
            }
            // 上下剪枝
            for (int i = r - 1; i <= r + 1; i++) {
                if (i >= 0 && i < rl && !used[i][c] && wi < wl
                        && board[i][c] == word[wi]) {
                    cs.push(new int[] { i, c });
                }
            }
        }
    }

}
</xmp>"	"leetcode"
"leetcode_82"	"<p>给定一个已排序的链表的头&nbsp;<code>head</code> ，&nbsp;<em>删除原始链表中所有重复数字的节点，只留下不同的数字</em>&nbsp;。返回 <em>已排序的链表</em>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg"" style=""height: 142px; width: 500px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,3,4,4,5]
<strong>输出：</strong>[1,2,5]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg"" style=""height: 164px; width: 400px;"" />
<pre>
<strong>输入：</strong>head = [1,1,1,2,3]
<strong>输出：</strong>[2,3]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
    <li><code>-100 &lt;= Node.val &lt;= 100</code></li>
    <li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<div><div>Related Topics</div><div><li>链表</li><li>双指针</li></div></div><br><div><li>👍 813</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode g = dummy, f = dummy, cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            if (next != null && next.val == cur.val) {

            } else {
                if (f.next == cur) {
                    g.next = cur;
                    f = cur;
                    g = f;
                } else {
                    f = cur;
                }

            }
            cur = next;
        }
        // 这一行非常重要
        g.next = cur;

        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_89"	"<strong>n 位格雷码序列</strong> 是一个由 <code>2<sup>n</sup></code> 个整数组成的序列，其中：
<ul>
    <li>每个整数都在范围 <code>[0, 2<sup>n</sup> - 1]</code> 内（含 <code>0</code> 和 <code>2<sup>n</sup> - 1</code>）</li>
    <li>第一个整数是 <code>0</code></li>
    <li>一个整数在序列中出现 <strong>不超过一次</strong></li>
    <li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li>
    <li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li>
</ul>

<p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 2
<strong>输出：</strong>[0,1,3,2]
<strong>解释：</strong>
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 0<strong><em>0</em></strong> 和 0<em><strong>1</strong></em> 有一位不同
- <em><strong>0</strong></em>1 和 <em><strong>1</strong></em>1 有一位不同
- 1<em><strong>1</strong></em> 和 1<em><strong>0</strong></em> 有一位不同
- <em><strong>1</strong></em>0 和 <em><strong>0</strong></em>0 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- <em><strong>0</strong></em>0 和 <em><strong>1</strong></em>0 有一位不同
- 1<em><strong>0</strong></em> 和 1<em><strong>1</strong></em> 有一位不同
- <em><strong>1</strong></em>1 和 <em><strong>0</strong></em>1 有一位不同
- 0<em><strong>1</strong></em> 和 0<em><strong>0</strong></em> 有一位不同
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>[0,1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 16</code></li>
</ul>
<div><div>Related Topics</div><div><li>位运算</li><li>数学</li><li>回溯</li></div></div><br><div><li>👍 473</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ans = new ArrayList<>();
        ans.add(0);
        while (n-- > 0) {
            int m = ans.size();
            for (int i = m - 1; i >= 0; i--) {
                ans.set(i, ans.get(i) << 1);
                ans.add(ans.get(i) + 1);
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_91"	"<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>

<pre>
'A' -&gt; ""1""
'B' -&gt; ""2""
...
'Z' -&gt; ""26""</pre>

<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>""11106""</code> 可以映射为：</p>

<ul>
    <li><code>""AAJF""</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
    <li><code>""KJF""</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>

<p>注意，消息不能分组为&nbsp; <code>(1 11 06)</code> ，因为 <code>""06""</code> 不能映射为 <code>""F""</code> ，这是由于 <code>""6""</code> 和 <code>""06""</code> 在映射中并不等价。</p>

<p>给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>

<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""12""
<strong>输出：</strong>2
<strong>解释：</strong>它可以解码为 ""AB""（1 2）或者 ""L""（12）。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""226""
<strong>输出：</strong>3
<strong>解释：</strong>它可以解码为 ""BZ"" (2 26), ""VF"" (22 6), 或者 ""BBF"" (2 2 6) 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = ""0""
<strong>输出：</strong>0
<strong>解释：</strong>没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -&gt; ""10"" 和 'T'-&gt; ""20"" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 100</code></li>
    <li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 1082</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int numDecodings(String s) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_92"	"给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left <= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。
<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5], left = 2, right = 4
<strong>输出：</strong>[1,4,3,2,5]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>head = [5], left = 1, right = 1
<strong>输出：</strong>[5]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点数目为 <code>n</code></li>
    <li><code>1 <= n <= 500</code></li>
    <li><code>-500 <= Node.val <= 500</code></li>
    <li><code>1 <= left <= right <= n</code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>
<div><div>Related Topics</div><div><li>链表</li></div></div><br><div><li>👍 1151</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1, head);
        ListNode g = dummy;
        int count = 1;
        while (count < left) {
            g = g.next;
            count++;
        }

        ListNode pre = null, cur = g.next;
        while (count <= right) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
            count++;
        }

        g.next.next = cur;
        g.next = pre;

        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_93"	"<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>

<ul>
    <li>例如：""0.1.2.201"" 和 ""192.168.1.1"" 是 <strong>有效</strong> IP 地址，但是 ""0.011.255.245""、""192.168.1.312"" 和 ""192.168@1.1"" 是 <strong>无效</strong> IP 地址。</li>
</ul>

<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入&nbsp;<code>'.'</code> 来形成。你不能重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""25525511135""
<strong>输出：</strong>[""255.255.11.135"",""255.255.111.35""]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""0000""
<strong>输出：</strong>[""0.0.0.0""]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = ""1111""
<strong>输出：</strong>[""1.1.1.1""]
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>s = ""010010""
<strong>输出：</strong>[""0.10.0.10"",""0.100.1.0""]
</pre>

<p><strong>示例 5：</strong></p>

<pre>
<strong>输入：</strong>s = ""101023""
<strong>输出：</strong>[""1.0.10.23"",""1.0.102.3"",""10.1.0.23"",""10.10.2.3"",""101.0.2.3""]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= s.length &lt;= 20</code></li>
    <li><code>s</code> 仅由数字组成</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>回溯</li></div></div><br><div><li>👍 789</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;
    char[] chars = null;
    LinkedList<Integer> c = new LinkedList<>();
    LinkedList<Integer> s = new LinkedList<>();

    public List<String> restoreIpAddresses(String str) {
        List<String> ans = new ArrayList<>();
        char[] $chars = str.toCharArray();
        length = $chars.length;
        chars = new char[length + 1];
        System.arraycopy($chars, 0, chars, 1, length);

        push(1);
        while (!c.isEmpty()) {
            Integer index = c.peek();
            if (s.isEmpty() || index.compareTo(s.peek()) != 0) {
                // 不相等说明是第一次
                s.push(index);
                push(index + 1);
            } else {
                if (s.size() == 4) {
                    List<String> temp = new ArrayList<>();
                    int last = 0;
                    for (int i = s.size() - 1; i >= 0; i--) {
                        temp.add(String.copyValueOf(chars, last + 1, s.get(i)
                                - last));
                        last = s.get(i);
                    }

                    ans.add(String.join(""."", temp));
                }
                c.pop();
                s.pop();
            }
        }

        return ans;
    }

    void push(int pre) {
        int size = s.size();
        if (size <= 3) {
            int remainSize = 3 - size;
            int cur = pre;
            while (cur <= pre + 2 && cur <= length) {
                int remain = length - cur;
                boolean trim = false;
                if (!(remainSize <= remain && remain <= 3 * remainSize)) {
                    // 不满足剩余条件就剪枝
                    trim = true;
                } else if (chars[pre] == '0' && cur > pre) {
                    trim = true;
                } else if (cur == pre + 2) {
                    int num = Integer.parseInt(String
                            .copyValueOf(chars, pre, 3));
                    if (num > 255) {
                        //不满足就跳过
                        trim = true;
                    }
                }
                // 放入
                if (!trim) {
                    c.push(cur);
                }
                cur++;
            }
        }
    }

}
</xmp>"	"leetcode"
"leetcode_96"	"<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"" style=""width: 600px; height: 148px;"" />
<pre>
<strong>输入：</strong>n = 3
<strong>输出：</strong>5
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= n <= 19</code></li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>二叉搜索树</li><li>数学</li><li>动态规划</li><li>二叉树</li></div></div><br><div><li>👍 1536</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            int count = 0;
            for (int j = 1; j <= i; j++) {
                count += dp[j - 1] * dp[i - j];
            }
            dp[i] = count;
        }
        return dp[n];
    }
}
</xmp>"	"leetcode"
"leetcode_98"	"<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>

<p><strong>有效</strong> 二叉搜索树定义如下：</p>

<ul>
    <li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li>
    <li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
    <li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"" style=""width: 302px; height: 182px;"" />
<pre>
<strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"" style=""width: 422px; height: 292px;"" />
<pre>
<strong>输入：</strong>root = [5,1,4,null,null,3,6]
<strong>输出：</strong>false
<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>
    <li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>二叉搜索树</li><li>二叉树</li></div></div><br><div><li>👍 1414</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean isValid(TreeNode root, long min, long max) {
        if (!(root.val > min && root.val < max)) {
            return false;
        }

        if (root.left != null && !isValid(root.left, min, root.val)) {
            return false;
        }

        if (root.right != null && !isValid(root.right, root.val, max)) {
            return false;
        }

        return true;

    }

}
</xmp>"	"leetcode"
"leetcode_102"	"<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"" style=""width: 277px; height: 302px;"" />
<pre>
<strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[3],[9,20],[15,7]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
    <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>广度优先搜索</li><li>二叉树</li></div></div><br><div><li>👍 1165</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    Queue<TreeNode> q = new LinkedList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        q.offer(root);
        int size = 0;
        while ((size = q.size()) > 0) {
            List<Integer> l = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                // 空节点直接跳过
                if (node == null)
                    continue;
                l.add(node.val);
                q.offer(node.left);
                q.offer(node.right);
            }
            if (l.size() > 0) {
                ans.add(l);
            }
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_103"	"<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"" style=""width: 277px; height: 302px;"" />
<pre>
<strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[3],[20,9],[15,7]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
    <li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>广度优先搜索</li><li>二叉树</li></div></div><br><div><li>👍 585</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {

    LinkedList<TreeNode> q = new LinkedList<>();

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();

        if (root == null)
            return ans;

        // flag == true 表示从左往右，flag == false 表示从右往左
        boolean flag = true;

        // 初始化
        q.push(root);

        while (!q.isEmpty()) {
            List<Integer> l = new ArrayList<>();
            int length = q.size();

            for (int i = 0; i < length; i++) {
                TreeNode n = q.poll();
                if (n.left != null)
                    q.offer(n.left);
                if (n.right != null)
                    q.offer(n.right);
                l.add(n.val);
            }

            if (!flag) {
                Collections.reverse(l);
            }

            flag = !flag;

            ans.add(l);
        }

        return ans;
    }

}
</xmp>"	"leetcode"
"leetcode_105"	"<p>给定两个整数数组&nbsp;<code>preorder</code> 和 <code>inorder</code>&nbsp;，其中&nbsp;<code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code>&nbsp;是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"" style=""height: 302px; width: 277px;"" />
<pre>
<strong>输入</strong><strong>:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
<strong>输出:</strong> [3,9,20,null,null,15,7]
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> preorder = [-1], inorder = [-1]
<strong>输出:</strong> [-1]
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
    <li><code>inorder.length == preorder.length</code></li>
    <li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
    <li><code>preorder</code>&nbsp;和&nbsp;<code>inorder</code>&nbsp;均 <strong>无重复</strong> 元素</li>
    <li><code>inorder</code>&nbsp;均出现在&nbsp;<code>preorder</code></li>
    <li><code>preorder</code>&nbsp;<strong>保证</strong> 为二叉树的前序遍历序列</li>
    <li><code>inorder</code>&nbsp;<strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>数组</li><li>哈希表</li><li>分治</li><li>二叉树</li></div></div><br><div><li>👍 1419</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return null;
    }
}
</xmp>"	"leetcode"
"leetcode_106"	"<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗&nbsp;<em>二叉树</em>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"" />
<pre>
<b>输入：</b>inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
<b>输出：</b>[3,9,20,null,null,15,7]
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<b>输入：</b>inorder = [-1], postorder = [-1]
<b>输出：</b>[-1]
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= inorder.length &lt;= 3000</code></li>
    <li><code>postorder.length == inorder.length</code></li>
    <li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>
    <li><code>inorder</code>&nbsp;和&nbsp;<code>postorder</code>&nbsp;都由 <strong>不同</strong> 的值组成</li>
    <li><code>postorder</code>&nbsp;中每一个值都在&nbsp;<code>inorder</code>&nbsp;中</li>
    <li><code>inorder</code>&nbsp;<strong>保证</strong>是树的中序遍历</li>
    <li><code>postorder</code>&nbsp;<strong>保证</strong>是树的后序遍历</li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>数组</li><li>哈希表</li><li>分治</li><li>二叉树</li></div></div><br><div><li>👍 672</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {

    int[] inorder = null;

    int[] postorder = null;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;

        int is = 0;
        int ie = inorder.length - 1;
        int ps = 0;
        int pe = postorder.length - 1;

        return buildTree(is, ie, ps, pe);
    }

    public TreeNode buildTree(int is, int ie, int ps, int pe) {
        if (pe < ps) {
            return null;
        }

        int root = postorder[pe];

        int i = is;
        while (i <= ie) {
            if (inorder[i] == root) {
                break;
            }
            i++;
        }

        TreeNode left = buildTree(is, i - 1, ps, ps + i - 1 - is);

        TreeNode right = buildTree(i + 1, ie, ps + i - is, pe - 1);

        return new TreeNode(root, left, right);
    }

}
</xmp>"	"leetcode"
"leetcode_116"	"<p>给定一个&nbsp;<strong>完美二叉树&nbsp;</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}</pre>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>

<p>初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2019/02/14/116_sample.png"" style=""height: 171px; width: 500px;"" /></p>

<pre>
<b>输入：</b>root = [1,2,3,4,5,6,7]
<b>输出：</b>[1,#,2,3,#,4,5,6,7,#]
<b>解释：</b>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
</pre>

<p><meta charset=""UTF-8"" /></p>

<p><strong>示例 2:</strong></p>

<pre>
<b>输入：</b>root = []
<b>输出：</b>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>树中节点的数量在<meta charset=""UTF-8"" />&nbsp;<code>[0, 2<sup>12</sup>&nbsp;- 1]</code>&nbsp;范围内</li>
    <li><code>-1000 &lt;= node.val &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong></p>

<ul>
    <li>你只能使用常量级额外空间。</li>
    <li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>广度优先搜索</li><li>链表</li><li>二叉树</li></div></div><br><div><li>👍 676</li><li>👎 0</li></div>"	"<xmp>/*
 // Definition for a Node.
 class Node {
 public int val;
 public Node left;
 public Node right;
 public Node next;

 public Node() {}

 public Node(int _val) {
 val = _val;
 }

 public Node(int _val, Node _left, Node _right, Node _next) {
 val = _val;
 left = _left;
 right = _right;
 next = _next;
 }
 };
 */

class Solution {

    LinkedList<Node> s = new LinkedList<>();

    public Node connect(Node root) {
        offer(root);
        while (!s.isEmpty()) {
            int count = s.size();
            Node pre = null;
            while (count > 0) {
                Node cur = s.poll();
                offer(cur.left);
                offer(cur.right);
                if (pre != null)
                    pre.next = cur;
                pre = cur;
                count--;
            }
        }

        return root;
    }

    void offer(Node root) {
        if (root != null)
            s.offer(root);
    }
}
</xmp>"	"leetcode"
"leetcode_121"	"<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>

<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>

<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>[7,1,5,3,6,4]
<strong>输出：</strong>5
<strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>prices = [7,6,4,3,1]
<strong>输出：</strong>0
<strong>解释：</strong>在这种情况下, 没有交易完成, 所以最大利润为 0。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= prices.length <= 10<sup>5</sup></code></li>
    <li><code>0 <= prices[i] <= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 2134</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] prices = null;

    public int maxProfit(int[] $prices) {
        length = $prices.length;
        prices = new int[length + 1];
        System.arraycopy($prices, 0, prices, 1, length);

        if (length == 1)
            return 0;

        int dp[][] = new int[2][length + 1];

        dp[0][1] = 0;
        dp[1][1] = -prices[1];

        int i = 2;
        while (i <= length) {
            dp[0][i] = Math.max(dp[0][i - 1], dp[1][i - 1] + prices[i]);
            dp[1][i] = Math.max(dp[1][i - 1], -prices[i]);
            i++;
        }
        return Math.max(dp[0][length], dp[1][length]);
    }
}
</xmp>"	"leetcode"
"leetcode_122"	"<p>给定一个数组 <code>prices</code> ，其中&nbsp;<code>prices[i]</code> 表示股票第 <code>i</code> 天的价格。</p>

<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候&nbsp;<strong>最多</strong>&nbsp;只能持有 <strong>一股</strong> 股票。你也可以购买它，然后在 <strong>同一天</strong> 出售。<br />
返回 <em>你能获得的 <strong>最大</strong> 利润</em>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> prices = [7,1,5,3,6,4]
<strong>输出:</strong> 7
<strong>解释:</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
&nbsp;    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> prices = [1,2,3,4,5]
<strong>输出:</strong> 4
<strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
&nbsp;    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</pre>

<p><strong>示例&nbsp;3:</strong></p>

<pre>
<strong>输入:</strong> prices = [7,6,4,3,1]
<strong>输出:</strong> 0
<strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= prices.length &lt;= 3 * 10<sup>4</sup></code></li>
    <li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1559</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] prices = null;

    public int maxProfit(int[] $prices) {
        length = $prices.length;
        prices = new int[length + 1];
        System.arraycopy($prices, 0, prices, 1, length);

        if (length == 1)
            return 0;

        int[][] dp = new int[2][length + 1];

        dp[0][1] = 0;
        dp[1][1] = -prices[1];

        int i = 2;

        while (i <= length) {
            dp[0][i] = Math.max(dp[0][i - 1], dp[1][i - 1] + prices[i]);
            dp[1][i] = Math.max(dp[1][i - 1], dp[0][i - 1] - prices[i]);
            i++;
        }

        return Math.max(dp[0][length], dp[1][length]);
    }
}
</xmp>"	"leetcode"
"leetcode_128"	"<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>

<p>请你设计并实现时间复杂度为 <code>O(n)</code><em> </em>的算法解决此问题。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [100,4,200,1,3,2]
<strong>输出：</strong>4
<strong>解释：</strong>最长数字连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]
<strong>输出：</strong>9
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= nums.length <= 10<sup>5</sup></code></li>
    <li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>并查集</li><li>数组</li><li>哈希表</li></div></div><br><div><li>👍 1069</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int longestConsecutive(int[] nums) {
        // 建立一个存储所有数的哈希表，同时起到去重功能
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int ans = 0;
        // 遍历所有数字，已经经过去重
        for (int num : set) {
            int cur = num;
            // 只有当num-1不存在时，才开始向后遍历num+1，num+2，num+3......
            if (!set.contains(cur - 1)) {
                while (set.contains(cur + 1)) {
                    cur++;
                }
            }
            // [num, cur]之间是连续的，数字有cur - num + 1个
            ans = Math.max(ans, cur - num + 1);
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_131"	"<p>给你一个字符串 <code>s</code>，请你将<em> </em><code>s</code><em> </em>分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>

<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""aab""
<strong>输出：</strong>[[""a"",""a"",""b""],[""aa"",""b""]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""a""
<strong>输出：</strong>[[""a""]]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= s.length <= 16</code></li>
    <li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li><li>回溯</li></div></div><br><div><li>👍 981</li><li>👎 0</li></div>"	"<xmp>class Solution {

    String str = null;
    boolean[][] f;
    List<List<String>> ans = new ArrayList<>();

    int i = 0;
    LinkedList<Integer> ss = new LinkedList<>();
    LinkedList<Integer> cs = new LinkedList<>();
    int n;

    public List<List<String>> partition(String str) {
        this.str = str;
        n = str.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(f[i], true);
        }
        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (str.charAt(i) == str.charAt(j)) && f[i + 1][j - 1];
            }
        }

        push();
        while (!cs.isEmpty()) {
            Integer c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                i = c;
                push();
            } else {
                if (c == n) {
                    addAns();
                }
                cs.pop();
                ss.pop();
            }
        }

        return ans;
    }

    void push() {
        int start = i, end = i;
        while (end < n) {
            if (f[start][end++]) {
                cs.push(end);
            }
        }
    }

    void addAns() {
        List<String> tempList = new ArrayList<>();
        int start = 0, end = 0;
        for (int j = ss.size() - 1; j >= 0; j--) {
            end = ss.get(j);
            tempList.add(str.substring(start, end));
            start = end;
        }
        ans.add(tempList);
    }
}
</xmp>"	"leetcode"
"leetcode_134"	"<p>在一条环路上有&nbsp;<em>N</em>&nbsp;个加油站，其中第&nbsp;<em>i</em>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code><em>&nbsp;</em>升。</p>

<p>你有一辆油箱容量无限的的汽车，从第<em> i </em>个加油站开往第<em> i+1&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。</p>

<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>

<p><strong>说明:</strong>&nbsp;</p>

<ul>
    <li>如果题目有解，该答案即为唯一答案。</li>
    <li>输入数组均为非空数组，且长度相同。</li>
    <li>输入数组中的元素均为非负数。</li>
</ul>

<p><strong>示例&nbsp;1:</strong></p>

<pre><strong>输入:</strong> 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

<strong>输出:</strong> 3

<strong>解释:
</strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。</pre>

<p><strong>示例 2:</strong></p>

<pre><strong>输入:</strong> 
gas  = [2,3,4]
cost = [3,4,3]

<strong>输出:</strong> -1

<strong>解释:
</strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。</pre>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li></div></div><br><div><li>👍 833</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //假设油箱里的汽油可以为负数，找到最小的负数就是出发点
        int n = gas.length;
        int curGas = 0, minGas = 0, minIndex = 0;//默认从0出发

        for (int i = 0; i < n; i++) {
            curGas = curGas + gas[i] - cost[i];//走过了第i段路后邮箱里的油
            if (curGas < minGas) {
                minGas = curGas;
                minIndex = i + 1;//这里i如果是n-1的话，说明当前汽油比0小，返回-1,不会返回错误的n。
            }
        }
        return curGas < 0 ? -1 : minIndex;//油箱为负值返回-1；
    }
}
</xmp>"	"leetcode"
"leetcode_138"	"<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>

<p>构造这个链表的&nbsp;<strong><a href=""https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin"" target=""_blank"">深拷贝</a></strong>。&nbsp;深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点 </strong>。</p>

<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>

<p>返回复制链表的头节点。</p>

<p>用一个由&nbsp;<code>n</code>&nbsp;个节点组成的链表来表示输入/输出中的链表。每个节点用一个&nbsp;<code>[val, random_index]</code>&nbsp;表示：</p>

<ul>
    <li><code>val</code>：一个表示&nbsp;<code>Node.val</code>&nbsp;的整数。</li>
    <li><code>random_index</code>：随机指针指向的节点索引（范围从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>）；如果不指向任何节点，则为&nbsp;&nbsp;<code>null</code>&nbsp;。</li>
</ul>

<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png"" style=""height: 142px; width: 700px;"" /></p>

<pre>
<strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png"" style=""height: 114px; width: 700px;"" /></p>

<pre>
<strong>输入：</strong>head = [[1,1],[2,1]]
<strong>输出：</strong>[[1,1],[2,1]]
</pre>

<p><strong>示例 3：</strong></p>

<p><strong><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png"" style=""height: 122px; width: 700px;"" /></strong></p>

<pre>
<strong>输入：</strong>head = [[3,null],[3,0],[3,null]]
<strong>输出：</strong>[[3,null],[3,0],[3,null]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 1000</code><meta charset=""UTF-8"" /></li>
    <li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>
    <li><code>Node.random</code>&nbsp;为&nbsp;<code>null</code> 或指向链表中的节点。</li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>链表</li></div></div><br><div><li>👍 819</li><li>👎 0</li></div>"	"<xmp>/*
 // Definition for a Node.
 class Node {
 int val;
 Node next;
 Node random;

 public Node(int val) {
 this.val = val;
 this.next = null;
 this.random = null;
 }
 }
 */

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        Node p = head;
        //第一步，在每个原节点后面创建一个新节点
        //1->1'->2->2'->3->3'
        while (p != null) {
            Node newNode = new Node(p.val);
            newNode.next = p.next;
            p.next = newNode;
            p = newNode.next;
        }
        p = head;
        //第二步，设置新节点的随机节点
        while (p != null) {
            if (p.random != null) {
                p.next.random = p.random.next;
            }
            p = p.next.next;
        }

        Node dummy = new Node(-1);
        p = head;
        Node cur = dummy;
        //第三步，将两个链表分离
        while (p != null) {
            cur.next = p.next;
            cur = cur.next;
            p.next = cur.next;
            p = p.next;
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_139"	"<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p>

<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入:</strong> s = ""leetcode"", wordDict = [""leet"", ""code""]
<strong>输出:</strong> true
<strong>解释:</strong> 返回 true 因为 ""leetcode"" 可以由 ""leet"" 和 ""code"" 拼接成。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入:</strong> s = ""applepenapple"", wordDict = [""apple"", ""pen""]
<strong>输出:</strong> true
<strong>解释:</strong> 返回 true 因为 <code>""</code>applepenapple<code>""</code> 可以由 <code>""</code>apple"" ""pen"" ""apple<code>"" 拼接成</code>。
&nbsp;    注意，你可以重复使用字典中的单词。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入:</strong> s = ""catsandog"", wordDict = [""cats"", ""dog"", ""sand"", ""and"", ""cat""]
<strong>输出:</strong> false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 300</code></li>
    <li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
    <li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
    <li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>
    <li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<div><div>Related Topics</div><div><li>字典树</li><li>记忆化搜索</li><li>哈希表</li><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 1382</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return true;
    }
}
</xmp>"	"leetcode"
"leetcode_141"	"<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>

<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递&nbsp;</strong>。仅仅是为了标识链表的实际情况。</p>

<p><em>如果链表中存在环</em>&nbsp;，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"" /></p>

<pre>
<strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre>

<p><strong>示例&nbsp;2：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"" /></p>

<pre>
<strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre>

<p><strong>示例 3：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"" /></p>

<pre>
<strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>false
<strong>解释：</strong>链表中没有环。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点的数目范围是 <code>[0, 10<sup>4</sup>]</code></li>
    <li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
    <li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<div><div>Related Topics</div><div><li>哈希表</li><li>链表</li><li>双指针</li></div></div><br><div><li>👍 1353</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast != null)
                fast = fast.next;
            if (slow == fast) {
                break;
            }
        }

        return fast != null;
    }
}
</xmp>"	"leetcode"
"leetcode_142"	"<p>给定一个链表的头节点 &nbsp;<code>head</code>&nbsp;，返回链表开始入环的第一个节点。&nbsp;<em>如果链表无环，则返回&nbsp;<code>null</code>。</em></p>

<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>

<p><strong>不允许修改 </strong>链表。</p>

<ul>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img src=""https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"" /></p>

<pre>
<strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>返回索引为 1 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre>

<p><strong>示例&nbsp;2：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"" /></p>

<pre>
<strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>返回索引为 0 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre>

<p><strong>示例 3：</strong></p>

<p><img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"" /></p>

<pre>
<strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>返回 null
<strong>解释：</strong>链表中没有环。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>
    <li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
    <li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<div><div>Related Topics</div><div><li>哈希表</li><li>链表</li><li>双指针</li></div></div><br><div><li>👍 1371</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast != null)
                fast = fast.next;
            if (slow == fast) {
                break;
            }
        }

        if (fast == null)
            return null;

        ListNode pre = head;
        while (pre != slow) {
            pre = pre.next;
            slow = slow.next;
        }

        return pre;
    }
}
</xmp>"	"leetcode"
"leetcode_143"	"<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>

<pre>
L<sub>0</sub> → L<sub>1</sub> → … → L<sub>n - 1</sub> → L<sub>n</sub>
</pre>

<p>请将其重新排列后变为：</p>

<pre>
L<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n - 1</sub> → L<sub>2</sub> → L<sub>n - 2</sub> → …</pre>

<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png"" style=""width: 240px; "" /></p>

<pre>
<strong>输入：</strong>head = [1,2,3,4]
<strong>输出：</strong>[1,4,2,3]</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="""" src=""https://pic.leetcode-cn.com/1626420320-YUiulT-image.png"" style=""width: 320px; "" /></p>

<pre>
<strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[1,5,2,4,3]</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>
    <li><code>1 &lt;= node.val &lt;= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>栈</li><li>递归</li><li>链表</li><li>双指针</li></div></div><br><div><li>👍 785</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    List<ListNode> list = new ArrayList<>();

    public void reorderList(ListNode head) {
        while (head != null) {
            list.add(head);
            head = head.next;
        }

        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;
        int i = 0, j = list.size() - 1;
        while (i <= j) {
            ListNode n1 = list.get(i);
            current.next = n1;
            if (i < j) {
                ListNode n2 = list.get(j);
                n1.next = n2;
                n2.next = null;
                current = n2;
            } else {
                n1.next = null;
            }
            i++;
            j--;
        }
    }
}
</xmp>"	"leetcode"
"leetcode_145"	"<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历 </strong>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg"" style=""width: 127px; height: 200px;"" />
<pre>
<strong>输入：</strong>root = [1,null,2,3]
<strong>输出：</strong>[3,2,1]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = [1]
<strong>输出：</strong>[1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>树中节点的数目在范围 <code>[0, 100]</code> 内</li>
    <li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>
<div><div>Related Topics</div><div><li>栈</li><li>树</li><li>深度优先搜索</li><li>二叉树</li></div></div><br><div><li>👍 755</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root, prev = null;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            TreeNode top = stack.peek();
            if (top.right == null || top.right == prev) {
                stack.pop();
                res.add(top.val);
                prev = top;
                cur = null;
            } else {
                cur = top.right;
            }
        }
        return res;
    }
}
</xmp>"	"leetcode"
"leetcode_146"	"<div class=""title__3Vvk"">请你设计并实现一个满足&nbsp; <a href=""https://baike.baidu.com/item/LRU"" target=""_blank"">LRU (最近最少使用) 缓存</a> 约束的数据结构。</div>

<div class=""title__3Vvk"">实现 <code>LRUCache</code> 类：</div>

<div class=""original__bRMd"">
<div>
<ul>
    <li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>
    <li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
    <li><code>void put(int key, int value)</code>&nbsp;如果关键字&nbsp;<code>key</code> 已经存在，则变更其数据值&nbsp;<code>value</code> ；如果不存在，则向缓存中插入该组&nbsp;<code>key-value</code> 。如果插入操作导致关键字数量超过&nbsp;<code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>

<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
</div>
</div>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入</strong>
[""LRUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>输出</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>解释</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= capacity &lt;= 3000</code></li>
    <li><code>0 &lt;= key &lt;= 10000</code></li>
    <li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
    <li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<div><div>Related Topics</div><div><li>设计</li><li>哈希表</li><li>链表</li><li>双向链表</li></div></div><br><div><li>👍 1871</li><li>👎 0</li></div>"	"<xmp>class LRUCache {

    public LRUCache(int capacity) {

    }

    public int get(int key) {
        return 0;
    }

    public void put(int key, int value) {

    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
</xmp>"	"leetcode"
"leetcode_147"	"<p>给定单个链表的头<meta charset=""UTF-8"" />&nbsp;<code>head</code>&nbsp;，使用 <strong>插入排序</strong> 对链表进行排序，并返回&nbsp;<em>排序后链表的头</em>&nbsp;。</p>

<p><strong>插入排序</strong>&nbsp;算法的步骤:</p>

<ol>
    <li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
    <li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
    <li>重复直到所有输入数据插入完为止。</li>
</ol>

<p>下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。</p>

<p>对链表进行插入排序。</p>

<p><img alt="""" src=""https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif"" /></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg"" /></p>

<pre>
<strong>输入:</strong> head = [4,2,1,3]
<strong>输出:</strong> [1,2,3,4]</pre>

<p><strong>示例&nbsp;2：</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg"" /></p>

<pre>
<strong>输入:</strong> head = [-1,5,3,4,0]
<strong>输出:</strong> [-1,0,3,4,5]</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<p><meta charset=""UTF-8"" /></p>

<ul>
    <li>列表中的节点数在&nbsp;<code>[1, 5000]</code>范围内</li>
    <li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<div><div>Related Topics</div><div><li>链表</li><li>排序</li></div></div><br><div><li>👍 483</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(Integer.MIN_VALUE, head);
        ListNode cur = head, next = null, p = null, q = null;
        while (cur != null) {
            next = cur.next;
            cur.next = null;

            p = dummy;
            q = dummy.next;

            while (q != null && q.val < cur.val) {
                p = q;
                q = q.next;
            }

            p.next = cur;
            if (cur != q)
                cur.next = q;

            cur = next;
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_148"	"<p>给你链表的头结点&nbsp;<code>head</code>&nbsp;，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>

<ul>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg"" style=""width: 450px;"" />
<pre>
<b>输入：</b>head = [4,2,1,3]
<b>输出：</b>[1,2,3,4]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg"" style=""width: 550px;"" />
<pre>
<b>输入：</b>head = [-1,5,3,4,0]
<b>输出：</b>[-1,0,3,4,5]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<b>输入：</b>head = []
<b>输出：</b>[]
</pre>

<p>&nbsp;</p>

<p><b>提示：</b></p>

<ul>
    <li>链表中节点的数目在范围&nbsp;<code>[0, 5 * 10<sup>4</sup>]</code>&nbsp;内</li>
    <li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>

<p><b>进阶：</b>你可以在&nbsp;<code>O(n&nbsp;log&nbsp;n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<div><div>Related Topics</div><div><li>链表</li><li>双指针</li><li>分治</li><li>排序</li><li>归并排序</li></div></div><br><div><li>👍 1459</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        int length = 0;
        ListNode node = head;
        while (node != null) {
            length++;
            node = node.next;
        }
        ListNode dummy = new ListNode(-1, head);
        for (int subLength = 1; subLength < length; subLength = 2 * subLength) {
            ListNode g = dummy, cur = dummy.next;
            while (cur != null) {
                ListNode head1 = cur;
                ListNode pre = null;
                for (int i = 1; i <= subLength && cur != null; i++) {
                    pre = cur;
                    cur = cur.next;
                }
                pre.next = null;

                pre = null;
                ListNode head2 = cur;

                for (int i = 1; i <= subLength && cur != null; i++) {
                    pre = cur;
                    cur = cur.next;
                }
                if (pre != null)
                    pre.next = null;

                ListNode merged = merge(head1, head2);
                g.next = merged;
                while (g.next != null) {
                    g = g.next;
                }
            }
        }
        return dummy.next;
    }

    ListNode merge(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy, p = list1, q = list2;
        while (p != null && q != null) {
            if (p.val <= q.val) {
                cur.next = p;
                p = p.next;
            } else {
                cur.next = q;
                q = q.next;
            }
            cur = cur.next;
        }
        if (p != null) {
            cur.next = p;
        } else if (q != null) {
            cur.next = q;
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_152"	"<p>给你一个整数数组 <code>nums</code>&nbsp;，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> [2,3,-2,4]
<strong>输出:</strong> <code>6</code>
<strong>解释:</strong>&nbsp;子数组 [2,3] 有最大乘积 6。
</pre>

<p><strong>示例 2:</strong></p>

<pre><strong>输入:</strong> [-2,0,-1]
<strong>输出:</strong> 0
<strong>解释:</strong>&nbsp;结果不能为 2, 因为 [-2,-1] 不是子数组。</pre>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1478</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;
    int[] nums = null;

    public int maxProduct(int[] $nums) {
        int ans = Integer.MIN_VALUE;

        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        int[] dpMax = new int[length + 1];
        int[] dpMin = new int[length + 1];
        // 相乘不改变大小
        dpMax[0] = 1;
        dpMin[0] = 1;

        for (int i = 1; i <= length; i++) {
            int max = 0;
            int min = 0;
            if (nums[i] > 0) {
                // 比0大，就正数乘以正数
                max = Math.max(dpMax[i - 1] * nums[i], nums[i]);
                min = Math.min(dpMin[i - 1] * nums[i], nums[i]);
            } else if (nums[i] < 0) {
                max = Math.max(dpMin[i - 1] * nums[i], nums[i]);
                min = Math.min(dpMax[i - 1] * nums[i], nums[i]);
            }
            dpMax[i] = max;
            dpMin[i] = min;
            ans = Math.max(dpMax[i], ans);
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_162"	"<p>峰值元素是指其值严格大于左右相邻值的元素。</p>

<p>给你一个整数数组&nbsp;<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>

<p>你可以假设&nbsp;<code>nums[-1] = nums[n] = -∞</code> 。</p>

<p>你必须实现时间复杂度为 <code>O(log n)</code><em> </em>的算法来解决此问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = <code>[1,2,3,1]</code>
<strong>输出：</strong>2
<strong>解释：</strong>3 是峰值元素，你的函数应该返回其索引 2。</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入：</strong>nums = <code>[</code>1,2,1,3,5,6,4]
<strong>输出：</strong>1 或 5 
<strong>解释：</strong>你的函数可以返回索引 1，其峰值元素为 2；
&nbsp;    或者返回索引 5， 其峰值元素为 6。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 1000</code></li>
    <li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
    <li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li></div></div><br><div><li>👍 703</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int findPeakElement(int[] $nums) {
        length = $nums.length;
        nums = new int[length + 2];
        System.arraycopy($nums, 0, nums, 1, length);
        nums[0] = Integer.MIN_VALUE;
        nums[length + 1] = Integer.MIN_VALUE;

        for (int i = 1; i <= length; i++) {
            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {
                return i - 1;
            }
        }

        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_165"	"<p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>

<p>版本号由一个或多个修订号组成，各修订号由一个 <code>'.'</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>

<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等 </strong>。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p>

<p>返回规则如下：</p>

<ul>
    <li>如果&nbsp;<code><em>version1&nbsp;</em>&gt;&nbsp;<em>version2</em></code>&nbsp;返回&nbsp;<code>1</code>，</li>
    <li>如果&nbsp;<code><em>version1&nbsp;</em>&lt;&nbsp;<em>version2</em></code> 返回 <code>-1</code>，</li>
    <li>除此之外返回 <code>0</code>。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>version1 = ""1.01"", version2 = ""1.001""
<strong>输出：</strong>0
<strong>解释：</strong>忽略前导零，""01"" 和 ""001"" 都表示相同的整数 ""1""
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>version1 = ""1.0"", version2 = ""1.0.0""
<strong>输出：</strong>0
<strong>解释：</strong>version1 没有指定下标为 2 的修订号，即视为 ""0""
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>version1 = ""0.1"", version2 = ""1.1""
<strong>输出：</strong>-1
<strong>解释：</strong>version1 中下标为 0 的修订号是 ""0""，version2 中下标为 0 的修订号是 ""1"" 。0 &lt; 1，所以 version1 &lt; version2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>
    <li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>'.'</code></li>
    <li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>
    <li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>
</ul>
<div><div>Related Topics</div><div><li>双指针</li><li>字符串</li></div></div><br><div><li>👍 264</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int compareVersion(String version1, String version2) {
        String[] strArr1 = version1.split(""\\."");
        String[] strArr2 = version2.split(""\\."");
        int length1 = strArr1.length;
        int length2 = strArr2.length;
        int length = Math.max(length1, length2);

        for (int i = 0; i < length; i++) {
            String v1 = i < length1 ? strArr1[i] : ""0"";
            String v2 = i < length2 ? strArr2[i] : ""0"";
            Integer n1 = Integer.valueOf(v1);
            Integer n2 = Integer.valueOf(v2);
            int ans = n1.compareTo(n2);
            if (ans != 0) {
                return ans;
            }
        }
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_167"	"<p>给你一个下标从 <strong>1</strong> 开始的整数数组&nbsp;<code>numbers</code> ，该数组已按<strong><em> </em>非递减顺序排列&nbsp; </strong>，请你从数组中找出满足相加之和等于目标数&nbsp;<code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index<sub>1</sub>]</code> 和 <code>numbers[index<sub>2</sub>]</code> ，则 <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code> 。</p>

<p>以长度为 2 的整数数组 <code>[index<sub>1</sub>, index<sub>2</sub>]</code> 的形式返回这两个整数的下标 <code>index<sub>1</sub></code><em> </em>和<em> </em><code>index<sub>2</sub></code>。</p>

<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>

<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
&nbsp;

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>numbers = [<strong><em>2</em></strong>,<strong><em>7</em></strong>,11,15], target = 9
<strong>输出：</strong>[1,2]
<strong>解释：</strong>2 与 7 之和等于目标数 9 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 2 。返回 [1, 2] 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>numbers = [<strong><em>2</em></strong>,3,<strong><em>4</em></strong>], target = 6
<strong>输出：</strong>[1,3]
<strong>解释：</strong>2 与 4 之和等于目标数 6 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 3 。返回 [1, 3] 。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>numbers = [<strong><em>-1</em></strong>,<strong><em>0</em></strong>], target = -1
<strong>输出：</strong>[1,2]
<strong>解释：</strong>-1 与 0 之和等于目标数 -1 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 2 。返回 [1, 2] 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>
    <li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
    <li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
    <li><code>-1000 &lt;= target &lt;= 1000</code></li>
    <li><strong>仅存在一个有效答案</strong></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>二分查找</li></div></div><br><div><li>👍 696</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;
    int[] nums = null;

    public int[] twoSum(int[] numbers, int target) {
        length = numbers.length;
        nums = new int[length + 1];
        System.arraycopy(numbers, 0, nums, 1, length);
        int l = 1, r = length;
        while (l < r) {
            int sum = nums[l] + nums[r];
            if (sum == target) {
                return new int[] { l, r };
            } else if (sum > target) {
                r--;
            } else {
                l++;
            }
        }
        return new int[] { -1, -1 };
    }
}
</xmp>"	"leetcode"
"leetcode_179"	"<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>

<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入<code>：</code></strong><code>nums = [10,2]</code>
<strong>输出：</strong><code>""210""</code></pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入<code>：</code></strong><code>nums = [3,30,34,5,9]</code>
<strong>输出：</strong><code>""9534330""</code>
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入<code>：</code></strong>nums = [1]
<strong>输出：</strong>""1""
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入<code>：</code></strong>nums = [10]
<strong>输出：</strong>""10""
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 100</code></li>
    <li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>字符串</li><li>排序</li></div></div><br><div><li>👍 869</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] ss = new String[n];
        for (int i = 0; i < n; i++)
            ss[i] = """" + nums[i];

        Arrays.sort(ss, (a, b) -> {
            String sa = a + b, sb = b + a;
            return sb.compareTo(sa);
        });

        StringBuilder sb = new StringBuilder();
        for (String s : ss)
            sb.append(s);
        int len = sb.length();
        int k = 0;
        while (k < len - 1 && sb.charAt(k) == '0')
            k++;
        return sb.substring(k);
    }
}
</xmp>"	"leetcode"
"leetcode_187"	"<p><strong>DNA序列</strong>&nbsp;由一系列核苷酸组成，缩写为<meta charset=""UTF-8"" />&nbsp;<code>'A'</code>,&nbsp;<code>'C'</code>,&nbsp;<code>'G'</code>&nbsp;和<meta charset=""UTF-8"" />&nbsp;<code>'T'</code>.。</p>

<ul>
    <li>例如，<meta charset=""UTF-8"" /><code>""ACGAATTCCG""</code>&nbsp;是一个 <strong>DNA序列</strong> 。</li>
</ul>

<p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p>

<p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的&nbsp;<strong>长度为&nbsp;<code>10</code></strong>&nbsp;的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""
<strong>输出：</strong>[""AAAAACCCCC"",""CCCCCAAAAA""]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""AAAAAAAAAAAAA""
<strong>输出：</strong>[""AAAAAAAAAA""]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
    <li><code>s[i]</code><code>==</code><code>'A'</code>、<code>'C'</code>、<code>'G'</code>&nbsp;or&nbsp;<code>'T'</code></li>
</ul>
<div><div>Related Topics</div><div><li>位运算</li><li>哈希表</li><li>字符串</li><li>滑动窗口</li><li>哈希函数</li><li>滚动哈希</li></div></div><br><div><li>👍 336</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        List<String> ans = new ArrayList<String>();
        Map<String, Integer> cnt = new HashMap<String, Integer>();
        int n = s.length();
        for (int i = 0; i <= n - 10; ++i) {
            String sub = s.substring(i, i + 10);
            cnt.put(sub, cnt.getOrDefault(sub, 0) + 1);
            if (cnt.get(sub) == 2) {
                ans.add(sub);
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_189"	"<p>给你一个数组，将数组中的元素向右轮转 <code>k</code><em>&nbsp;</em>个位置，其中&nbsp;<code>k</code><em>&nbsp;</em>是非负数。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 3
<strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code>
<strong>解释:</strong>
向右轮转 1 步: <code>[7,1,2,3,4,5,6]</code>
向右轮转 2 步: <code>[6,7,1,2,3,4,5]
</code>向右轮转 3 步: <code>[5,6,7,1,2,3,4]</code>
</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>
<strong>输入：</strong>nums = [-1,-100,3,99], k = 2
<strong>输出：</strong>[3,99,-1,-100]
<strong>解释:</strong> 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
    <li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
    <li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong></p>

<ul>
    <li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
    <li>你可以使用空间复杂度为&nbsp;<code>O(1)</code> 的&nbsp;<strong>原地&nbsp;</strong>算法解决这个问题吗？</li>
</ul>

<ul>
</ul>

<ul>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>数学</li><li>双指针</li></div></div><br><div><li>👍 1308</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += 1;
            end -= 1;
        }
    }
}
</xmp>"	"leetcode"
"leetcode_198"	"<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>

<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>[1,2,3,1]
<strong>输出：</strong>4
<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>[2,7,9,3,1]
<strong>输出：</strong>12
<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 100</code></li>
    <li><code>0 <= nums[i] <= 400</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1869</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int rob(int[] $nums) {
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        int dp[][] = new int[2][length + 1];

        dp[0][1] = 0;
        dp[1][1] = nums[1];

        int i = 2;
        while (i <= length) {
            dp[0][i] = Math.max(dp[1][i - 1], dp[0][i - 1]);
            dp[1][i] = Math.max(dp[1][i - 2], dp[0][i - 1]) + nums[i];
            i++;
        }

        return Math.max(dp[0][length], dp[1][length]);
    }
}
</xmp>"	"leetcode"
"leetcode_200"	"<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>

<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>

<p>此外，你可以假设该网格的四条边均被水包围。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>grid = [
  [""1"",""1"",""1"",""1"",""0""],
  [""1"",""1"",""0"",""1"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""0"",""0"",""0""]
]
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [
  [""1"",""1"",""0"",""0"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""1"",""0"",""0""],
  [""0"",""0"",""0"",""1"",""1""]
]
<strong>输出：</strong>3
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == grid.length</code></li>
    <li><code>n == grid[i].length</code></li>
    <li><code>1 <= m, n <= 300</code></li>
    <li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
<div><div>Related Topics</div><div><li>深度优先搜索</li><li>广度优先搜索</li><li>并查集</li><li>数组</li><li>矩阵</li></div></div><br><div><li>👍 1552</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int rl = 0;
    int cl = 0;
    char[][] grid = null;

    int r = -1, c = -1, ans = 0, count = 0;
    LinkedList<int[]> cs = new LinkedList<>();
    LinkedList<int[]> ss = new LinkedList<>();
    boolean[][] used = null;

    public int numIslands(char[][] $grid) {
        rl = $grid.length;
        cl = $grid[0].length;
        grid = $grid;
        used = new boolean[rl][cl];

        push();
        while (!cs.isEmpty()) {
            int[] ca = cs.peek();
            if (ss.peek() != ca) {
                r = ca[0];
                c = ca[1];
                if (used[r][c]) {
                    // 使用过了
                    cs.pop();
                } else {
                    ss.push(ca);
                    used[r][c] = true;
                    push();
                }
            } else {
                ss.pop();
                cs.pop();
                if (ss.isEmpty()) {
                    ans++;
                }
            }
        }

        return ans;
    }

    void push() {
        if (r == -1 && c == -1) {
            for (int i = 0; i < rl; i++) {
                for (int j = 0; j < cl; j++) {
                    if (grid[i][j] == '1') {
                        cs.push(new int[] { i, j });
                    }
                }
            }
        } else {
            for (int i = c - 1; i <= c + 1; i++) {
                if (i >= 0 && i <= cl - 1 && !used[r][i] && grid[r][i] == '1') {
                    cs.push(new int[] { r, i });
                }
            }

            for (int i = r - 1; i <= r + 1; i++) {
                if (i >= 0 && i <= rl - 1 && !used[i][c] && grid[i][c] == '1') {
                    cs.push(new int[] { i, c });
                }
            }
        }

    }

}
</xmp>"	"leetcode"
"leetcode_206"	"给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。
<div class=""original__bRMd"">
<div>
<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg"" style=""width: 182px; height: 222px;"" />
<pre>
<strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
    <li><code>-5000 <= Node.val <= 5000</code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
</div>
</div>
<div><div>Related Topics</div><div><li>递归</li><li>链表</li></div></div><br><div><li>👍 2264</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null, cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
</xmp>"	"leetcode"
"leetcode_207"	"<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>

<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示如果要学习课程 <code>a<sub>i</sub></code> 则 <strong>必须</strong> 先学习课程  <code>b<sub>i</sub></code><sub> </sub>。</p>

<ul>
    <li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>

<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]
<strong>输出：</strong>true
<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>输出：</strong>false
<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= numCourses <= 10<sup>5</sup></code></li>
    <li><code>0 <= prerequisites.length <= 5000</code></li>
    <li><code>prerequisites[i].length == 2</code></li>
    <li><code>0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses</code></li>
    <li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>
</ul>
<div><div>Related Topics</div><div><li>深度优先搜索</li><li>广度优先搜索</li><li>图</li><li>拓扑排序</li></div></div><br><div><li>👍 1117</li><li>👎 0</li></div>"	"<xmp></xmp>"	"leetcode"
"leetcode_209"	"<p>给定一个含有 <code>n</code><strong> </strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>

<p>找出该数组中满足其和<strong> </strong><code>≥ target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong> <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]
<strong>输出：</strong>2
<strong>解释：</strong>子数组 <code>[4,3]</code> 是该条件下的长度最小的子数组。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>target = 4, nums = [1,4,4]
<strong>输出：</strong>1
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]
<strong>输出：</strong>0
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= target <= 10<sup>9</sup></code></li>
    <li><code>1 <= nums.length <= 10<sup>5</sup></code></li>
    <li><code>1 <= nums[i] <= 10<sup>5</sup></code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong></p>

<ul>
    <li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li><li>前缀和</li><li>滑动窗口</li></div></div><br><div><li>👍 943</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int lo = 0, hi = 0, sum = 0, min = Integer.MAX_VALUE;
        while (hi < nums.length) {
            sum += nums[hi++];
            while (sum >= target) {
                min = Math.min(min, hi - lo);
                sum -= nums[lo++];
            }
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}
</xmp>"	"leetcode"
"leetcode_215"	"<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>

<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2
<strong>输出:</strong> 5
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4
<strong>输出:</strong> 4</pre>

<p> </p>

<p><strong>提示： </strong></p>

<ul>
    <li><code>1 <= k <= nums.length <= 10<sup>4</sup></code></li>
    <li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>分治</li><li>快速选择</li><li>排序</li><li>堆（优先队列）</li></div></div><br><div><li>👍 1463</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int k = 0;
    int length = 0;
    int[] nums = null;

    int left = 0, right = 0, mid = -1;
    LinkedList<int[]> cs = new LinkedList<>();
    LinkedList<int[]> ss = new LinkedList<>();

    public int findKthLargest(int[] $nums, int $k) {
        length = $nums.length;
        k = $k;
        left = 1;
        right = length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        push();
        while (!cs.isEmpty()) {
            int[] c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                left = c[0];
                right = c[1];
                mid = c[2];
                push();
            } else {
                if (c[2] == length - (k - 1)) {
                    return nums[c[2]];
                }
                ss.pop();
                cs.pop();
            }
        }

        return 0;
    }

    void push() {
        if (left > right)
            return;
        int l = left, r = right, pivot = nums[left];
        while (l <= r) {
            while (l <= r && nums[l] <= pivot)
                l++;
            while (l <= r && nums[r] > pivot)
                r--;
            if (l <= r) {
                swap(l, r);
            }
        }
        mid = l - 1;
        swap(mid, left);
        if (mid <= length - (k - 1)) {
            cs.push(new int[] { mid + 1, right, mid });
        } else {
            cs.push(new int[] { left, mid - 1, mid });
        }
    }

    void swap(int a, int b) {
        nums[0] = nums[a];
        nums[a] = nums[b];
        nums[b] = nums[0];
    }
}
</xmp>"	"leetcode"
"leetcode_221"	"<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg"" style=""width: 400px; height: 319px;"" />
<pre>
<strong>输入：</strong>matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
<strong>输出：</strong>4
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg"" style=""width: 165px; height: 165px;"" />
<pre>
<strong>输入：</strong>matrix = [[""0"",""1""],[""1"",""0""]]
<strong>输出：</strong>1
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>matrix = [[""0""]]
<strong>输出：</strong>0
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == matrix.length</code></li>
    <li><code>n == matrix[i].length</code></li>
    <li><code>1 <= m, n <= 300</code></li>
    <li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li><li>矩阵</li></div></div><br><div><li>👍 1029</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int n = 0;
    int m = 0;

    public int maximalSquare(char[][] matrix) {

        int maxSide = 0;
        n = matrix.length;
        m = matrix[0].length;

        int[][] dp = new int[n + 1][m + 1];

        int i = 1;

        while (i <= n) {
            int j = 1;
            while (j <= m) {
                if (matrix[i - 1][j - 1] == '1') {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),
                            dp[i - 1][j - 1]) + 1;
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
                j++;
            }
            i++;
        }

        return maxSide * maxSide;
    }

}
</xmp>"	"leetcode"
"leetcode_227"	"<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>

<p>整数除法仅保留整数部分。</p>

<div class=""original__bRMd"">
<div>
<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""3+2*2""
<strong>输出：</strong>7
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "" 3/2 ""
<strong>输出：</strong>1
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "" 3+5 / 2 ""
<strong>输出：</strong>5
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= s.length <= 3 * 10<sup>5</sup></code></li>
    <li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>
    <li><code>s</code> 表示一个 <strong>有效表达式</strong></li>
    <li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 2<sup>31</sup> - 1]</code> 内</li>
    <li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>
</ul>
</div>
</div>
<div><div>Related Topics</div><div><li>栈</li><li>数学</li><li>字符串</li></div></div><br><div><li>👍 530</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int calculate(String s) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_236"	"<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>

<p><a href=""https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin"" target=""_blank"">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"" style=""width: 200px; height: 190px;"" />
<pre>
<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>输出：</strong>3
<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"" style=""width: 200px; height: 190px;"" />
<pre>
<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>输出：</strong>5
<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = [1,2], p = 1, q = 2
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>
    <li><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code></li>
    <li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>
    <li><code>p != q</code></li>
    <li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>二叉树</li></div></div><br><div><li>👍 1535</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode(int x) { val = x; }
 * }
 */
class Solution {

    int count = 0;
    TreeNode r = null;
    LinkedList<TreeNode> ss = new LinkedList<>();
    LinkedList<TreeNode> cs = new LinkedList<>();

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        LinkedList<TreeNode> s1 = new LinkedList<>();
        LinkedList<TreeNode> s2 = new LinkedList<>();

        r = root;
        push();
        while (!cs.isEmpty()) {
            TreeNode c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                if (c == p || c == q) {
                    count++;
                    if (count == 1) {
                        s1.addAll(ss);
                    } else {
                        s2.addAll(ss);
                        break;
                    }
                }
                r = c.left;
                push();
                r = c.right;
                push();
            } else {
                ss.pop();
                cs.pop();
            }
        }

        TreeNode ans = null;
        while (s1.peekLast() == s2.peekLast()) {
            ans = s1.peekLast();
            s1.pollLast();
            s2.pollLast();
        }
        return ans;
    }

    void push() {
        if (r != null) {
            cs.push(r);
        }
    }

}
</xmp>"	"leetcode"
"leetcode_240"	"<p>编写一个高效的算法来搜索&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>

<ul>
    <li>每行的元素从左到右升序排列。</li>
    <li>每列的元素从上到下升序排列。</li>
</ul>

<p>&nbsp;</p>

<p><b>示例 1：</b></p>
<img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg"" />
<pre>
<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
<b>输出：</b>true
</pre>

<p><b>示例 2：</b></p>
<img alt="""" src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg"" />
<pre>
<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
<b>输出：</b>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == matrix.length</code></li>
    <li><code>n == matrix[i].length</code></li>
    <li><code>1 &lt;= n, m &lt;= 300</code></li>
    <li><code>-10<sup>9</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
    <li>每行的所有元素从左到右升序排列</li>
    <li>每列的所有元素从上到下升序排列</li>
    <li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li><li>分治</li><li>矩阵</li></div></div><br><div><li>👍 923</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        return false;
    }
}
</xmp>"	"leetcode"
"leetcode_287"	"<p>给定一个包含&nbsp;<code>n + 1</code> 个整数的数组&nbsp;<code>nums</code> ，其数字都在&nbsp;<code>[1, n]</code>&nbsp;范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>

<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回&nbsp;<strong>这个重复的数</strong> 。</p>

<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,3,4,2,2]
<strong>输出：</strong>2
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,1,3,4,2]
<strong>输出：</strong>3
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
    <li><code>nums.length == n + 1</code></li>
    <li><code>1 &lt;= nums[i] &lt;= n</code></li>
    <li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>

<p>&nbsp;</p>

<p><b>进阶：</b></p>

<ul>
    <li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>
    <li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>
</ul>
<div><div>Related Topics</div><div><li>位运算</li><li>数组</li><li>双指针</li><li>二分查找</li></div></div><br><div><li>👍 1583</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        int pre = 0;
        while (pre != slow) {
            pre = nums[pre];
            slow = nums[slow];
        }
        return pre;
    }
}
</xmp>"	"leetcode"
"leetcode_300"	"<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>

<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
 

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]
<strong>输出：</strong>4
<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,1,0,3,2,3]
<strong>输出：</strong>4
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [7,7,7,7,7,7,7]
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 2500</code></li>
    <li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>
</ul>

<p> </p>

<p><b>进阶：</b></p>

<ul>
    <li>你可以设计时间复杂度为 <code>O(n<sup>2</sup>)</code> 的解决方案吗？</li>
    <li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li><li>动态规划</li></div></div><br><div><li>👍 2195</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int lengthOfLIS(int[] $nums) {
        int ans = 0;

        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);
        nums[0] = Integer.MIN_VALUE;
        int[] dp = new int[length + 1];

        int i = 1;
        while (i <= length) {
            int j = 0;
            int max = 0;
            while (j < i) {
                if (nums[j] < nums[i]) {
                    max = Math.max(max, dp[j] + 1);
                }
                j++;
            }
            dp[i] = max;
            ans = Math.max(ans, max);
            i++;
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_306"	"<p><strong>累加数</strong> 是一个字符串，组成它的数字可以形成累加序列。</p>

<p>一个有效的 <strong>累加序列</strong> 必须<strong> 至少 </strong>包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。</p>

<p>给你一个只包含数字&nbsp;<code>'0'-'9'</code>&nbsp;的字符串，编写一个算法来判断给定输入是否是 <strong>累加数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p><strong>说明：</strong>累加序列里的数，除数字 0 之外，<strong>不会</strong> 以 0 开头，所以不会出现&nbsp;<code>1, 2, 03</code> 或者&nbsp;<code>1, 02, 3</code>&nbsp;的情况。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong><code>""112358""</code>
<strong>输出：</strong>true 
<strong>解释：</strong>累加序列为: <code>1, 1, 2, 3, 5, 8 </code>。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入<code>：</code></strong><code>""199100199""</code>
<strong>输出：</strong>true 
<strong>解释：</strong>累加序列为: <code>1, 99, 100, 199。</code>1 + 99 = 100, 99 + 100 = 199</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= num.length &lt;= 35</code></li>
    <li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你计划如何处理由过大的整数输入导致的溢出?</p>
<div><div>Related Topics</div><div><li>字符串</li><li>回溯</li></div></div><br><div><li>👍 340</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public boolean isAdditiveNumber(String num) {
        return dfs(num, 0, 0, 0, 0);
    }

    private boolean dfs(String num, int index, int count, long prevprev,
            long prev) {
        if (index >= num.length()) {
            return count > 2;
        }
        long current = 0;
        for (int i = index; i < num.length(); i++) {
            char c = num.charAt(i);
            if (num.charAt(index) == '0' && i > index) {
                // 剪枝1：不能做为前导0，但是它自己是可以单独做为0来使用的
                return false;
            }
            current = current * 10 + c - '0';

            if (count >= 2) {
                long sum = prevprev + prev;
                if (current > sum) {
                    // 剪枝2：如果当前数比之前两数的和大了，说明不合适
                    return false;
                }
                if (current < sum) {
                    // 剪枝3：如果当前数比之前两数的和小了，说明还不够，可以继续添加新的字符进来
                    continue;
                }
            }
            // 当前满足条件了，或者还不到两个数，向下一层探索
            if (dfs(num, i + 1, count + 1, prev, current)) {
                return true;
            }
        }
        return false;
    }
}
</xmp>"	"leetcode"
"leetcode_309"	"<p>给定一个整数数组<meta charset=""UTF-8"" /><code>prices</code>，其中第&nbsp;<em>&nbsp;</em><code>prices[i]</code>&nbsp;表示第&nbsp;<code><em>i</em></code>&nbsp;天的股票价格 。​</p>

<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>

<ul>
    <li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>

<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> prices = [1,2,3,0,2]
<strong>输出: </strong>3 
<strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> prices = [1]
<strong>输出:</strong> 0
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= prices.length &lt;= 5000</code></li>
    <li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1050</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] prices = null;

    public int maxProfit(int[] $prices) {
        length = $prices.length;
        prices = new int[length + 1];
        System.arraycopy($prices, 0, prices, 1, length);

        if (length == 1)
            return 0;

        int[][] dp = new int[2][length + 1];

        dp[0][1] = 0;
        dp[1][1] = -prices[1];
        dp[0][2] = Math.max(dp[0][1], dp[1][1] + prices[2]);
        dp[1][2] = Math.max(dp[1][1], -prices[2]);

        int i = 3;
        while (i <= length) {
            dp[0][i] = Math.max(dp[0][i - 1], dp[1][i - 1] + prices[i]);
            dp[1][i] = Math.max(dp[1][i - 1], dp[0][i - 2] - prices[i]);
            i++;
        }

        return Math.max(dp[0][length], dp[1][length]);
    }
}
</xmp>"	"leetcode"
"leetcode_319"	"<p>初始时有&nbsp;<code>n</code><em> </em>个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。</p>

<p>第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 <code>i</code> 轮，你每 <code>i</code> 个灯泡就切换第 <code>i</code> 个灯泡的开关。直到第 <code>n</code> 轮，你只需要切换最后一个灯泡的开关。</p>

<p>找出并返回 <code>n</code><em>&nbsp;</em>轮后有多少个亮着的灯泡。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg"" style=""width: 421px; height: 321px;"" /></p>

<pre>
<strong>输入：</strong>n =<strong> </strong>3
<strong>输出：</strong>1 
<strong>解释：</strong>
初始时, 灯泡状态 <strong>[关闭, 关闭, 关闭]</strong>.
第一轮后, 灯泡状态 <strong>[开启, 开启, 开启]</strong>.
第二轮后, 灯泡状态 <strong>[开启, 关闭, 开启]</strong>.
第三轮后, 灯泡状态 <strong>[开启, 关闭, 关闭]</strong>. 

你应该返回 1，因为只有一个灯泡还亮着。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 0
<strong>输出：</strong>0
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>脑筋急转弯</li><li>数学</li></div></div><br><div><li>👍 303</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int bulbSwitch(int n) {
        return (int) Math.sqrt(n);
    }
}
</xmp>"	"leetcode"
"leetcode_328"	"<p>给定单链表的头节点&nbsp;<code>head</code>&nbsp;，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>

<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为&nbsp;<strong>偶数</strong> ，以此类推。</p>

<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>

<p>你必须在&nbsp;<code>O(1)</code>&nbsp;的额外空间复杂度和&nbsp;<code>O(n)</code>&nbsp;的时间复杂度下解决这个问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<p><img src=""https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg"" style=""height: 123px; width: 300px;"" /></p>

<pre>
<strong>输入: </strong>head = [1,2,3,4,5]
<strong>输出:</strong>&nbsp;[1,3,5,2,4]</pre>

<p><strong>示例 2:</strong></p>

<p><img src=""https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg"" style=""height: 142px; width: 500px;"" /></p>

<pre>
<strong>输入:</strong> head = [2,1,3,5,6,4,7]
<strong>输出:</strong> [2,3,6,7,1,5,4]</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>n ==&nbsp;</code> 链表中的节点数</li>
    <li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>
    <li><code>-10<sup>6</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>6</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>链表</li></div></div><br><div><li>👍 538</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode dummy2 = new ListNode(-1, null);
        if (head != null) {
            dummy2.next = head.next;
        }

        ListNode odd = dummy.next, even = dummy2.next;
        while (odd != null) {
            if (even != null && even.next != null) {
                odd.next = even.next;
                odd = odd.next;
                even.next = odd.next;
                even = even.next;
            } else {
                odd.next = dummy2.next;
                odd = null;
            }
        }
        return dummy.next;
    }
}
</xmp>"	"leetcode"
"leetcode_334"	"<p>给你一个整数数组&nbsp;<code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>

<p>如果存在这样的三元组下标 <code>(i, j, k)</code>&nbsp;且满足 <code>i &lt; j &lt; k</code> ，使得&nbsp;<code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3,4,5]
<strong>输出：</strong>true
<strong>解释：</strong>任何 i &lt; j &lt; k 的三元组都满足题意
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [5,4,3,2,1]
<strong>输出：</strong>false
<strong>解释：</strong>不存在满足题意的三元组</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,1,5,0,4,6]
<strong>输出：</strong>true
<strong>解释：</strong>三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>
    <li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你能实现时间复杂度为 <code>O(n)</code> ，空间复杂度为 <code>O(1)</code> 的解决方案吗？</p>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li></div></div><br><div><li>👍 537</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public boolean increasingTriplet(int[] nums) {
        return false;
    }
}
</xmp>"	"leetcode"
"leetcode_343"	"<p>给定一个正整数&nbsp;<code>n</code>&nbsp;，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（&nbsp;<code>k &gt;= 2</code>&nbsp;），并使这些整数的乘积最大化。</p>

<p>返回 <em>你可以获得的最大乘积</em>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入: </strong>n = 2
<strong>输出: </strong>1
<strong>解释: </strong>2 = 1 + 1, 1 × 1 = 1。</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre>
<strong>输入: </strong>n = 10
<strong>输出: </strong>36
<strong>解释: </strong>10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
<div><div>Related Topics</div><div><li>数学</li><li>动态规划</li></div></div><br><div><li>👍 703</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        int i = 2;
        while (i <= n) {
            int curMax = 0;
            int j = 1;
            while (j < i) {
                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
                j++;
            }
            dp[i] = curMax;
            i++;
        }
        return dp[n];
    }
}
</xmp>"	"leetcode"
"leetcode_371"	"<p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用 </strong>运算符&nbsp;<code>+</code> 和&nbsp;<code>-</code>&nbsp;​​​​​​​，计算并返回两整数之和。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>a = 1, b = 2
<strong>输出：</strong>3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>a = 2, b = 3
<strong>输出：</strong>5
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>-1000 &lt;= a, b &lt;= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>位运算</li><li>数学</li></div></div><br><div><li>👍 584</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int getSum(int a, int b) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_384"	"<p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是&nbsp;<strong>等可能</strong>&nbsp;的。</p>

<p>实现 <code>Solution</code> class:</p>

<ul>
    <li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>
    <li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>
    <li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入</strong>
[""Solution"", ""shuffle"", ""reset"", ""shuffle""]
[[[1, 2, 3]], [], [], []]
<strong>输出</strong>
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

<strong>解释</strong>
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 200</code></li>
    <li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
    <li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li>
    <li>最多可以调用 <code>5 * 10<sup>4</sup></code> 次 <code>reset</code> 和 <code>shuffle</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>数学</li><li>随机化</li></div></div><br><div><li>👍 262</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public Solution(int[] nums) {

    }

    public int[] reset() {
        return null;
    }

    public int[] shuffle() {
        return null;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */
</xmp>"	"leetcode"
"leetcode_390"	"<p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p>

<div class=""original__bRMd"">
<div>
<ul>
    <li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li>
    <li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li>
    <li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li>
</ul>

<p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 9
<strong>输出：</strong>6
<strong>解释：</strong>
arr = [<strong><em>1</em></strong>, 2, <em><strong>3</strong></em>, 4, <em><strong>5</strong></em>, 6, <em><strong>7</strong></em>, 8, <em><strong>9</strong></em>]
arr = [2, <em><strong>4</strong></em>, 6, <em><strong>8</strong></em>]
arr = [<em><strong>2</strong></em>, 6]
arr = [6]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
</div>
<div><div>Related Topics</div><div><li>数学</li></div></div><br><div><li>👍 269</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int lastRemaining(int n) {
        int num = n;//当前数组元素个数
        boolean leftToRight = true;//判断此时是从左到右还是从右到左删除
        int head = 1;//首项
        int d = 1;//公差
        while (num != 1) {
            if (num % 2 == 1) {//num为奇数
                head = head + d;//无论从左到右还是从右到左第一位都会被删，首项都会改变
            } else if (num % 2 == 0) {
                if (leftToRight)
                    head = head + d;//从左到右删首项会改变
                else
                    head = head;//从右到左删首项不变
            }
            leftToRight = !leftToRight;//每一轮改变删除方向
            d *= 2;//公差变大
            num /= 2;//个数向下取1/2
        }
        return head;
    }
}
</xmp>"	"leetcode"
"leetcode_394"	"<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>

<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>

<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>

<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""3[a]2[bc]""
<strong>输出：</strong>""aaabcbc""
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""3[a2[c]]""
<strong>输出：</strong>""accaccacc""
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = ""2[abc]3[cd]ef""
<strong>输出：</strong>""abcabccdcdcdef""
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>s = ""abc3[cd]xyz""
<strong>输出：</strong>""abccdcdcdxyz""
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 30</code></li>
    <li><meta charset=""UTF-8"" /><code>s</code>&nbsp;由小写英文字母、数字和方括号<meta charset=""UTF-8"" />&nbsp;<code>'[]'</code> 组成</li>
    <li><code>s</code>&nbsp;保证是一个&nbsp;<strong>有效</strong>&nbsp;的输入。</li>
    <li><code>s</code>&nbsp;中所有整数的取值范围为<meta charset=""UTF-8"" />&nbsp;<code>[1, 300]</code>&nbsp;</li>
</ul>
<div><div>Related Topics</div><div><li>栈</li><li>递归</li><li>字符串</li></div></div><br><div><li>👍 1022</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String decodeString(String s) {
        StringBuilder content = new StringBuilder();
        int multi = 0;
        LinkedList<Integer> stackMulti = new LinkedList<>();
        LinkedList<String> stackContent = new LinkedList<>();
        for (Character c : s.toCharArray()) {
            if (c == '[') {
                stackMulti.push(multi);
                stackContent.push(content.toString());
                multi = 0;
                content = new StringBuilder();
            } else if (c == ']') {
                StringBuilder tmp = new StringBuilder();
                int lastMulti = stackMulti.pop();
                // 当前文本内容累乘
                for (int i = 0; i < lastMulti; i++)
                    tmp.append(content);
                // 累乘内容 加上 上一个数组前，在'['后的内容
                String lastContent = stackContent.pop();
                content = new StringBuilder(lastContent + tmp);
            } else if (c >= '0' && c <= '9') {
                // 乘数
                multi = multi * 10 + c - '0';
            } else {
                // 字符串
                content.append(c);
            }
        }
        return content.toString();
    }
}
</xmp>"	"leetcode"
"leetcode_400"	"<p>给你一个整数 <code>n</code> ，请你在无限的整数序列&nbsp;<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第&nbsp;<code>n</code><em> </em>位上的数字。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 3
<strong>输出：</strong>3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 11
<strong>输出：</strong>0
<strong>解释：</strong>第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 <strong>0 </strong>，它是 10 的一部分。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
<div><div>Related Topics</div><div><li>数学</li><li>二分查找</li></div></div><br><div><li>👍 294</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int findNthDigit(int $n) {
        int digital = 1;
        long start = 1;
        long n = $n;
        while (n > 9 * digital * start) {
            n = n - 9 * digital * start;
            start = start * 10;
            digital++;
        }
        long i = (long) Math.ceil(1.0 * n / digital);
        long num = start + i - 1;
        long k = n - (i - 1) * digital;

        return (int) ((num / (long) Math.pow(10, digital - k)) % 10);
    }
}
</xmp>"	"leetcode"
"leetcode_416"	"<p>给你一个 <strong>只包含正整数 </strong>的 <strong>非空 </strong>数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,5,11,5]
<strong>输出：</strong>true
<strong>解释：</strong>数组可以分割成 [1, 5, 5] 和 [11] 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3,5]
<strong>输出：</strong>false
<strong>解释：</strong>数组不能分割成两个元素和相等的子集。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 200</code></li>
    <li><code>1 <= nums[i] <= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 1127</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;
    int[] nums = null;

    public boolean canPartition(int[] $nums) {
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        // 题目已经说非空数组，可以不做非空判断
        int sum = 0;
        for (int num : $nums) {
            sum += num;
        }
        // 特判：如果是奇数，就不符合要求
        if ((sum & 1) == 1) {
            return false;
        }
        int target = sum / 2;
        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        boolean[][] dp = new boolean[length + 1][target + 1];

        // 初始化, 其实dp[1][0], dp[2][0], ..., dp[length][0] 都应该初始化为true, 不过可以延迟在flag = dp[i - 1][j]中初始化
        dp[0][0] = true;

        int i = 1;
        while (i <= length) {
            // 空就代表能装下
            int j = 0;
            while (j <= target) {
                boolean flag = false;
                if (nums[i] > j) {
                    // 装不下, 只能选择上面dp[i-1][j]的结果
                    flag = dp[i - 1][j];
                } else {
                    // 能装下，可以不装选择上面dp[i-1][j]的结果，或者选择装dp[i - 1][target - j]
                    flag = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
                dp[i][j] = flag;
                j++;
            }
            i++;
        }
        return dp[length][target];
    }
}
</xmp>"	"leetcode"
"leetcode_423"	"<p>给你一个字符串 <code>s</code> ，其中包含字母顺序打乱的用英文单词表示的若干数字（<code>0-9</code>）。按 <strong>升序</strong> 返回原始的数字。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""owoztneoer""
<strong>输出：</strong>""012""
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""fviefuro""
<strong>输出：</strong>""45""
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
    <li><code>s[i]</code> 为 <code>[""e"",""g"",""f"",""i"",""h"",""o"",""n"",""s"",""r"",""u"",""t"",""w"",""v"",""x"",""z""]</code> 这些字符之一</li>
    <li><code>s</code> 保证是一个符合题目要求的字符串</li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>数学</li><li>字符串</li></div></div><br><div><li>👍 177</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String originalDigits(String s) {

        return null;
    }
}
</xmp>"	"leetcode"
"leetcode_438"	"<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和 <code>p</code>，找到&nbsp;<code>s</code><strong>&nbsp;</strong>中所有&nbsp;<code>p</code><strong>&nbsp;</strong>的&nbsp;<strong>异位词&nbsp;</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>

<p><strong>异位词 </strong>指由相同字母重排列形成的字符串（包括相同的字符串）。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1:</strong></p>

<pre>
<strong>输入: </strong>s = ""cbaebabacd"", p = ""abc""
<strong>输出: </strong>[0,6]
<strong>解释:</strong>
起始索引等于 0 的子串是 ""cba"", 它是 ""abc"" 的异位词。
起始索引等于 6 的子串是 ""bac"", 它是 ""abc"" 的异位词。
</pre>

<p><strong>&nbsp;示例 2:</strong></p>

<pre>
<strong>输入: </strong>s = ""abab"", p = ""ab""
<strong>输出: </strong>[0,1,2]
<strong>解释:</strong>
起始索引等于 0 的子串是 ""ab"", 它是 ""ab"" 的异位词。
起始索引等于 1 的子串是 ""ba"", 它是 ""ab"" 的异位词。
起始索引等于 2 的子串是 ""ab"", 它是 ""ab"" 的异位词。
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>
    <li><code>s</code>&nbsp;和&nbsp;<code>p</code>&nbsp;仅包含小写字母</li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>字符串</li><li>滑动窗口</li></div></div><br><div><li>👍 776</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();

        int m = s.length();
        int n = p.length();
        if (m < n) {
            return ans;
        }

        int[] cnt = new int[26];
        // diff记录的是差异的字符类别数，不是字符个数
        int diff = 0;

        for (int i = 0; i < n; i++) {
            cnt[s.charAt(i) - 'a']++;
            cnt[p.charAt(i) - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (cnt[i] != 0) {
                // 统计差异数
                diff++;
            }
        }
        if (diff == 0) {
            ans.add(0);
        }
        for (int i = 0; i < m - n; i++) {
            if (--cnt[s.charAt(i) - 'a'] == 0) {
                // 移除窗口左边的字符后，这个字符的词频数变成了0，diff减1
                diff--;
            } else if (cnt[s.charAt(i) - 'a'] == -1) {
                // 这个字符的词频数变成-1，说明原来是0，diff加1
                diff++;
            }
            if (++cnt[s.charAt(i + n) - 'a'] == 1) {
                // 增加窗口右边的字符后，这个字符的词频数变成了1，diff加1
                diff++;
            } else if (cnt[s.charAt(i + n) - 'a'] == 0) {
                // 这个字符的词频数变成0，说明原来是-1，diff减1
                diff--;
            }
            if (diff == 0) {
                // 注意，diff统计的是差异的字符类别，等于0说明不存在差异的字符，可以直接加入答案
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_442"	"<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回。</p>

<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [4,3,2,7,8,2,3,1]
<strong>输出：</strong>[2,3]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,2]
<strong>输出：</strong>[1]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1]
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == nums.length</code></li>
    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= nums[i] &lt;= n</code></li>
    <li><code>nums</code> 中的每个元素出现 <strong>一次</strong> 或 <strong>两次</strong></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li></div></div><br><div><li>👍 471</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        int n = nums.length;
        List<Integer> ans = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int j = nums[i];
            nums[(j - 1) % n] = nums[(j - 1) % n] + n;
        }

        for (int i = 0; i < n; i++) {
            if (nums[i] < 3 * n + 1 && nums[i] > 2 * n) {
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_443"	"<p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p>

<p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p>

<ul>
    <li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li>
    <li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li>
</ul>

<p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p>

<p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p>

<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>chars = [""a"",""a"",""b"",""b"",""c"",""c"",""c""]
<strong>输出：</strong>返回 6 ，输入数组的前 6 个字符应该是：[""a"",""2"",""b"",""2"",""c"",""3""]
<strong>解释：</strong>
""aa"" 被 ""a2"" 替代。""bb"" 被 ""b2"" 替代。""ccc"" 被 ""c3"" 替代。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>chars = [""a""]
<strong>输出：</strong>返回 1 ，输入数组的前 1 个字符应该是：[""a""]
<strong>解释：</strong>
没有任何字符串被替代。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>chars = [""a"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b""]
<strong>输出：</strong>返回 4 ，输入数组的前 4 个字符应该是：[""a"",""b"",""1"",""2""]。
<strong>解释：</strong>
由于字符 ""a"" 不重复，所以不会被压缩。""bbbbbbbbbbbb"" 被 “b12” 替代。
注意每个数字在数组中都有它自己的位置。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= chars.length &lt;= 2000</code></li>
    <li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li>
</ul>
<div><div>Related Topics</div><div><li>双指针</li><li>字符串</li></div></div><br><div><li>👍 288</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int compress(char[] chars) {
        int n = chars.length, write = 0;
        for (int i = 0; i < n;) {
            int j = i;
            // j 负责找到后一个不相同的地方
            while (j < n && chars[i] == chars[j])
                j++;
            chars[write++] = chars[i];
            if (j - i > 1) {
                String tmp = Integer.toString(j - i);
                for (int k = 0; k < tmp.length(); k++)
                    chars[write++] = tmp.charAt(k);
            }
            i = j;
        }
        return write;
    }
}
</xmp>"	"leetcode"
"leetcode_475"	"<p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>

<p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p>

<p>现在，给出位于一条水平线上的房屋 <code>houses</code> 和供暖器 <code>heaters</code> 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p>

<p><strong>说明</strong>：所有供暖器都遵循你的半径标准，加热的半径也一样。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> houses = [1,2,3], heaters = [2]
<strong>输出:</strong> 1
<strong>解释:</strong> 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> houses = [1,2,3,4], heaters = [1,4]
<strong>输出:</strong> 1
<strong>解释:</strong> 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>houses = [1,5], heaters = [2]
<strong>输出：</strong>3
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= houses.length, heaters.length <= 3 * 10<sup>4</sup></code></li>
    <li><code>1 <= houses[i], heaters[i] <= 10<sup>9</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>二分查找</li><li>排序</li></div></div><br><div><li>👍 371</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        Arrays.sort(houses);
        Arrays.sort(heaters);
        int ans = 0;
        for (int i = 0, j = 0; i < houses.length; i++) {
            int curDistance = Math.abs(houses[i] - heaters[j]);
            while (j < heaters.length - 1
                    && Math.abs(houses[i] - heaters[j]) >= Math.abs(houses[i]
                            - heaters[j + 1])) {
                j++;
                curDistance = Math.min(curDistance,
                        Math.abs(houses[i] - heaters[j]));
            }
            ans = Math.max(ans, curDistance);
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_494"	"<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>

<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>

<ul>
    <li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>""+2-1""</code> 。</li>
</ul>

<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,1,1,1], target = 3
<strong>输出：</strong>5
<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1], target = 1
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 20</code></li>
    <li><code>0 <= nums[i] <= 1000</code></li>
    <li><code>0 <= sum(nums[i]) <= 1000</code></li>
    <li><code>-1000 <= target <= 1000</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>动态规划</li><li>回溯</li></div></div><br><div><li>👍 1057</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int findTargetSumWays(int[] $nums, int target) {
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        int[][] dp = new int[length + 1][2001];

        dp[0][1000] = 1;

        for (int i = 1; i <= length; i++) {
            for (int j = 0; j < 2001; j++) {
                int add = j - nums[i] < 0 ? 0 : dp[i - 1][j - nums[i]];
                int minus = j + nums[i] > 2000 ? 0 : dp[i - 1][j + nums[i]];
                if (add != 0 || minus != 0) {
                    dp[i][j] = add + minus;
                }
            }
        }
        return dp[length][target + 1000];
    }

}
</xmp>"	"leetcode"
"leetcode_498"	"<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg"" style=""width: 334px; height: 334px;"" />
<pre>
<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>[1,2,4,7,5,3,6,8,9]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>mat = [[1,2],[3,4]]
<strong>输出：</strong>[1,2,3,4]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == mat.length</code></li>
    <li><code>n == mat[i].length</code></li>
    <li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>
    <li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>
    <li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>矩阵</li><li>模拟</li></div></div><br><div><li>👍 269</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int m = 0;
    int n = 0;

    public int[] findDiagonalOrder(int[][] mat) {

        m = mat.length;
        n = mat[0].length;
        int length = m * n; // 元素个数
        int r = 0; //当前行
        int c = 0; //当前列

        int[] ans = new int[m * n];
        for (int i = 0; i < length; ++i) {
            ans[i] = mat[r][c];
            if ((r + c) % 2 == 0) { // 右上
                if (c == n - 1)
                    r++; // 如果是最后一列，不能再修改列数y了，会越界
                else if (r == 0)
                    c++; // 如果是第一行，向右即可;
                else {
                    r--;
                    c++;
                } // 正常右上
            } else { // 左下
                if (r == m - 1)
                    ++c; //如果是最后一行，不能再修改行数x了，会越界
                else if (c == 0)
                    ++r; //如果是第一列，向下即可;
                else {
                    ++r;
                    --c;
                } //正常左下
            }
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_516"	"<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>

<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""bbbab""
<strong>输出：</strong>4
<strong>解释：</strong>一个可能的最长回文子序列为 ""bbbb"" 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""cbbd""
<strong>输出：</strong>2
<strong>解释：</strong>一个可能的最长回文子序列为 ""bb"" 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= s.length <= 1000</code></li>
    <li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 722</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    char[] chars = null;

    public int longestPalindromeSubseq(String s) {
        length = s.length();
        chars = new char[length + 1];
        System.arraycopy(s.toCharArray(), 0, chars, 1, length);

        int[][] dp = new int[length + 1][length + 1];

        int i = length;
        while (i >= 1) {
            int j = i;
            while (j <= length) {
                if (chars[i] == chars[j]) {
                    dp[i][j] = i + 1 > j - 1 ? j - i + 1 : dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
                j++;
            }
            i--;
        }

        return dp[1][length];
    }
}
</xmp>"	"leetcode"
"leetcode_524"	"<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回&nbsp;<code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p>

<p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""abpcplea"", dictionary = [""ale"",""apple"",""monkey"",""plea""]
<strong>输出：</strong>""apple""
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""abpcplea"", dictionary = [""a"",""b"",""c""]
<strong>输出：</strong>""a""
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 1000</code></li>
    <li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>
    <li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>
    <li><code>s</code> 和 <code>dictionary[i]</code> 仅由小写英文字母组成</li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>字符串</li><li>排序</li></div></div><br><div><li>👍 288</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        Collections.sort(dictionary, new Comparator<String>() {
            public int compare(String word1, String word2) {
                if (word1.length() != word2.length()) {
                    return word2.length() - word1.length();
                } else {
                    return word1.compareTo(word2);
                }
            }
        });
        for (String t : dictionary) {
            int i = 0, j = 0;
            while (i < t.length() && j < s.length()) {
                if (t.charAt(i) == s.charAt(j)) {
                    ++i;
                }
                ++j;
            }
            if (i == t.length()) {
                return t;
            }
        }
        return """";
    }
}
</xmp>"	"leetcode"
"leetcode_528"	"<p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p>

<p>请你实现一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code>&nbsp;的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p>

<ol>
</ol>

<ul>
    <li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，<code>75%</code>）。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>
[""Solution"",""pickIndex""]
[[[1]],[]]
<strong>输出：</strong>
[null,0]
<strong>解释：</strong>
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>
[""Solution"",""pickIndex"",""pickIndex"",""pickIndex"",""pickIndex"",""pickIndex""]
[[[1,3]],[],[],[],[],[]]
<strong>输出：</strong>
[null,1,1,1,1,0]
<strong>解释：</strong>
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。

由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
诸若此类。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>
    <li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>
    <li><code>pickIndex</code>&nbsp;将被调用不超过 <code>10<sup>4</sup></code>&nbsp;次</li>
</ul>
<div><div>Related Topics</div><div><li>数学</li><li>二分查找</li><li>前缀和</li><li>随机化</li></div></div><br><div><li>👍 204</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public Solution(int[] w) {

    }

    public int pickIndex() {
        return 0;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(w);
 * int param_1 = obj.pickIndex();
 */
</xmp>"	"leetcode"
"leetcode_539"	"<p>给定一个 24 小时制（小时:分钟 <strong>""HH:MM""</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>timePoints = [""23:59"",""00:00""]
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>timePoints = [""00:00"",""23:59"",""00:00""]
<strong>输出：</strong>0
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>2 &lt;= timePoints.length &lt;= 2 * 10<sup>4</sup></code></li>
    <li><code>timePoints[i]</code> 格式为 <strong>""HH:MM""</strong></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>数学</li><li>字符串</li><li>排序</li></div></div><br><div><li>👍 189</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;

    public int findMinDifference(List<String> $timePoints) {
        length = $timePoints.size();
        int[] timePoints = new int[length];

        for (int i = 0; i < $timePoints.size(); i++) {
            String $timePoint = $timePoints.get(i);
            int hour = Integer.parseInt($timePoint.substring(0, 2));
            int min = Integer.parseInt($timePoint.substring(3, 5));
            timePoints[i] = hour * 60 + min;
        }

        Arrays.sort(timePoints);

        int min = Integer.MAX_VALUE;
        for (int i = 1; i < length; i++) {
            min = Math.min(min, timePoints[i] - timePoints[i - 1]);
        }

        int last = timePoints[length - 1] - timePoints[0];
        min = Math.min(min, Math.min(last, 24 * 60 - last));
        return min;
    }

}
</xmp>"	"leetcode"
"leetcode_542"	"<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>

<p>两个相邻元素间的距离为 <code>1</code> 。</p>

<p> </p>

<p><b>示例 1：</b></p>

<p><img alt="""" src=""https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png"" style=""width: 150px; "" /></p>

<pre>
<strong>输入：</strong>mat =<strong> </strong>[[0,0,0],[0,1,0],[0,0,0]]
<strong>输出：</strong>[[0,0,0],[0,1,0],[0,0,0]]
</pre>

<p><b>示例 2：</b></p>

<p><img alt="""" src=""https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png"" style=""width: 150px; "" /></p>

<pre>
<b>输入：</b>mat =<b> </b>[[0,0,0],[0,1,0],[1,1,1]]
<strong>输出：</strong>[[0,0,0],[0,1,0],[1,2,1]]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == mat.length</code></li>
    <li><code>n == mat[i].length</code></li>
    <li><code>1 <= m, n <= 10<sup>4</sup></code></li>
    <li><code>1 <= m * n <= 10<sup>4</sup></code></li>
    <li><code>mat[i][j] is either 0 or 1.</code></li>
    <li><code>mat</code> 中至少有一个 <code>0 </code></li>
</ul>
<div><div>Related Topics</div><div><li>广度优先搜索</li><li>数组</li><li>动态规划</li><li>矩阵</li></div></div><br><div><li>👍 609</li><li>👎 0</li></div>"	"<xmp></xmp>"	"leetcode"
"leetcode_560"	"<p>给你一个整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，请你统计并返回该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,1], k = 2
<strong>输出：</strong>2
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3], k = 3
<strong>输出：</strong>2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
    <li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
    <li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>前缀和</li></div></div><br><div><li>👍 1299</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        //细节，这里需要预存前缀和为 0 的情况，会漏掉前几位就满足的情况
        //例如输入[1,1,0]，k = 2 如果没有这行代码，则会返回0,漏掉了1+1=2，和1+1+0=2的情况
        //输入：[3,1,1,0] k = 2时则不会漏掉
        //因为presum[3] - presum[0]表示前面 3 位的和，所以需要map.put(0,1),垫下底
        map.put(0, 1);
        int count = 0;
        int presum = 0;
        for (int x : nums) {
            presum += x;
            //当前前缀和已知，判断是否含有 presum - k的前缀和，那么我们就知道某一区间的和为 k 了。
            if (map.containsKey(presum - k)) {
                count += map.get(presum - k);//获取次数
            }
            //更新
            map.put(presum, map.getOrDefault(presum, 0) + 1);
        }
        return count;
    }
}
</xmp>"	"leetcode"
"leetcode_567"	"<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s1 = ""ab"" s2 = ""eidbaooo""
<strong>输出：</strong>true
<strong>解释：</strong>s2 包含 s1 的排列之一 (""ba"").
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s1= ""ab"" s2 = ""eidboaoo""
<strong>输出：</strong>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>
    <li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>
</ul>
<div><div>Related Topics</div><div><li>哈希表</li><li>双指针</li><li>字符串</li><li>滑动窗口</li></div></div><br><div><li>👍 567</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int n = s1.length(), m = s2.length();
        if (n > m) {
            return false;
        }
        int[] cnt = new int[26];
        for (int i = 0; i < n; ++i) {
            --cnt[s1.charAt(i) - 'a'];
            ++cnt[s2.charAt(i) - 'a'];
        }
        int diff = 0;
        for (int c : cnt) {
            if (c != 0) {
                ++diff;
            }
        }
        if (diff == 0) {
            return true;
        }
        for (int i = n; i < m; ++i) {
            int x = s2.charAt(i) - 'a', y = s2.charAt(i - n) - 'a';
            if (x == y) {
                continue;
            }
            if (cnt[x] == 0) {
                ++diff;
            }
            ++cnt[x];
            if (cnt[x] == 0) {
                --diff;
            }
            if (cnt[y] == 0) {
                ++diff;
            }
            --cnt[y];
            if (cnt[y] == 0) {
                --diff;
            }
            if (diff == 0) {
                return true;
            }
        }
        return false;
    }
}
</xmp>"	"leetcode"
"leetcode_611"	"<p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> [2,2,3,4]
<strong>输出:</strong> 3
<strong>解释:</strong>
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
</pre>

<p><strong>注意:</strong></p>

<ol>
    <li>数组长度不超过1000。</li>
    <li>数组里整数的范围为 [0, 1000]。</li>
</ol>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>双指针</li><li>二分查找</li><li>排序</li></div></div><br><div><li>👍 341</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int triangleNumber(int[] $nums) {
        int ans = 0;
        Arrays.sort($nums);
        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        int i = 1;
        while (i <= length - 2) {
            int j = i + 1;
            while (j <= length - 1) {
                int target = nums[i] + nums[j];

                int l = j + 1;
                int r = length;
                while (l < r) {
                    int mid = (r + l) / 2;
                    if (target <= nums[mid]) {
                        r = mid;
                    } else {
                        l = mid + 1;
                    }
                }

                ans += nums[l] < target ? l - j : l - j - 1;
                j++;
            }
            i++;
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_621"	"<p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>

<p>然而，两个<strong> 相同种类</strong> 的任务之间必须有长度为整数<strong> </strong><code>n</code><strong> </strong>的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>

<p>你需要计算完成所有任务所需要的<strong> 最短时间</strong> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 2
<strong>输出：</strong>8
<strong>解释：</strong>A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 0
<strong>输出：</strong>6
<strong>解释：</strong>在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
[""A"",""A"",""A"",""B"",""B"",""B""]
[""A"",""B"",""A"",""B"",""A"",""B""]
[""B"",""B"",""B"",""A"",""A"",""A""]
...
诸如此类
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>tasks = [""A"",""A"",""A"",""A"",""A"",""A"",""B"",""C"",""D"",""E"",""F"",""G""], n = 2
<strong>输出：</strong>16
<strong>解释：</strong>一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= task.length <= 10<sup>4</sup></code></li>
    <li><code>tasks[i]</code> 是大写英文字母</li>
    <li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>哈希表</li><li>计数</li><li>排序</li><li>堆（优先队列）</li></div></div><br><div><li>👍 825</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] chars = new int[26];
        int max = 0;
        for (char task : tasks) {
            max = Math.max(++chars[task - 'A'], max);
        }
        int result = (max - 1) * (n + 1);
        for (int i = 0; i < 26; i++) {
            if (chars[i] == max) {
                result++;
            }
        }
        return Math.max(result, tasks.length);
    }
}
</xmp>"	"leetcode"
"leetcode_647"	"<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>

<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>

<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>

<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = ""abc""
<strong>输出：</strong>3
<strong>解释：</strong>三个回文子串: ""a"", ""b"", ""c""
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = ""aaa""
<strong>输出：</strong>6
<strong>解释：</strong>6个回文子串: ""a"", ""a"", ""a"", ""aa"", ""aa"", ""aaa""</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 1000</code></li>
    <li><code>s</code> 由小写英文字母组成</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 776</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    char[] chars = null;

    public int countSubstrings(String s) {
        int ans = 0;
        length = s.length();
        chars = new char[length + 1];
        System.arraycopy(s.toCharArray(), 0, chars, 1, length);
        boolean[][] dp = new boolean[length + 1][length + 1];

        // 遍历顺序不一样
        for (int i = length; i >= 1; --i) {
            for (int j = i; j <= length; ++j) {
                dp[i][j] = (chars[i] == chars[j])
                        && (i + 1 > j - 1 || dp[i + 1][j - 1]);

                if (dp[i][j])
                    ans++;
            }
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_670"	"<p>给定一个非负整数，你<strong>至多</strong>可以交换一次数字中的任意两位。返回你能得到的最大值。</p>

<p><strong>示例 1 :</strong></p>

<pre>
<strong>输入:</strong> 2736
<strong>输出:</strong> 7236
<strong>解释:</strong> 交换数字2和数字7。
</pre>

<p><strong>示例 2 :</strong></p>

<pre>
<strong>输入:</strong> 9973
<strong>输出:</strong> 9973
<strong>解释:</strong> 不需要交换。
</pre>

<p><strong>注意:</strong></p>

<ol>
    <li>给定数字的范围是&nbsp;[0, 10<sup>8</sup>]</li>
</ol>
<div><div>Related Topics</div><div><li>贪心</li><li>数学</li></div></div><br><div><li>👍 223</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int maximumSwap(int num) {
        return 0;
    }
}
</xmp>"	"leetcode"
"leetcode_673"	"<p>给定一个未排序的整数数组<meta charset=""UTF-8"" />&nbsp;<code>nums</code>&nbsp;，&nbsp;<em>返回最长递增子序列的个数</em>&nbsp;。</p>

<p><strong>注意</strong>&nbsp;这个数列必须是 <strong>严格</strong> 递增的。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> [1,3,5,4,7]
<strong>输出:</strong> 2
<strong>解释:</strong> 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> [2,2,2,2,2]
<strong>输出:</strong> 5
<strong>解释:</strong> 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong>&nbsp;</p>

<p><meta charset=""UTF-8"" /></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 2000</code></li>
    <li><code>-10<sup>6</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>树状数组</li><li>线段树</li><li>数组</li><li>动态规划</li></div></div><br><div><li>👍 545</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] nums = null;

    public int findNumberOfLIS(int[] $nums) {
        int ans = 0;
        int max = 0;

        length = $nums.length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        nums[0] = Integer.MIN_VALUE;
        int[] dp = new int[length + 1];
        int[] counts = new int[length + 1];

        counts[0] = 1;

        int i = 1;
        while (i <= length) {
            int j = 0;
            int curCount = 0;
            int curMax = 0;
            while (j < i) {
                if (nums[j] < nums[i]) {
                    if (dp[j] + 1 > curMax)
                        curCount = counts[j];
                    else if (dp[j] + 1 == curMax)
                        curCount += counts[j];
                    curMax = Math.max(curMax, dp[j] + 1);
                }
                j++;
            }
            dp[i] = curMax;
            counts[i] = curCount;
            if (dp[i] > max)
                ans = counts[i];
            else if (dp[i] == max)
                ans += counts[i];
            max = Math.max(max, dp[i]);
            i++;
        }

        return ans;
    }

}
</xmp>"	"leetcode"
"leetcode_695"	"<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>

<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>

<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>

<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg"" style=""width: 500px; height: 310px;"" />
<pre>
<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
<strong>输出：</strong>6
<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]
<strong>输出：</strong>0
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == grid.length</code></li>
    <li><code>n == grid[i].length</code></li>
    <li><code>1 &lt;= m, n &lt;= 50</code></li>
    <li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<div><div>Related Topics</div><div><li>深度优先搜索</li><li>广度优先搜索</li><li>并查集</li><li>数组</li><li>矩阵</li></div></div><br><div><li>👍 686</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int n, m;

    public int maxAreaOfIsland(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        int res = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                int nums = dfs(grid, i, j);
                res = Math.max(res, nums);
            }
        }

        return res;
    }

    int dfs(int[][] grid, int i, int j) {
        if (i < 0 || j < 0 || i >= n || j >= m) {
            return 0;
        }

        if (grid[i][j] != 1) {
            return 0;
        } else {
            grid[i][j] = 2;
            int r1 = dfs(grid, i + 1, j);
            int r2 = dfs(grid, i, j + 1);
            int r3 = dfs(grid, i - 1, j);
            int r4 = dfs(grid, i, j - 1);
            return 1 + r1 + r2 + r3 + r4;
        }
    }
}
</xmp>"	"leetcode"
"leetcode_718"	"<p>给两个整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度&nbsp;</em>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
<strong>输出：</strong>3
<strong>解释：</strong>长度最长的公共子数组是 [3,2,1] 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
<strong>输出：</strong>5
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
    <li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>二分查找</li><li>动态规划</li><li>滑动窗口</li><li>哈希函数</li><li>滚动哈希</li></div></div><br><div><li>👍 613</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length1 = 0;
    int[] nums1 = null;
    int length2 = 0;
    int[] nums2 = null;

    public int findLength(int[] $nums1, int[] $nums2) {
        int ans = 0;

        length1 = $nums1.length;
        nums1 = new int[length1 + 1];
        System.arraycopy($nums1, 0, nums1, 1, length1);

        length2 = $nums2.length;
        nums2 = new int[length2 + 1];
        System.arraycopy($nums2, 0, nums2, 1, length2);

        int dp[][] = new int[length1 + 1][length2 + 2];

        int i = 1;
        while (i <= length1) {
            int j = 1;
            while (j <= length2) {
                if (nums1[i] == nums2[j]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    ans = Math.max(ans, dp[i][j]);
                } else {
                    dp[i][j] = 0;
                }
                j++;
            }
            i++;
        }
        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_725"	"<p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p>

<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>

<p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>

<p>返回一个由上述 <code>k</code> 部分组成的数组。</p>
&nbsp;

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg"" style=""width: 400px; height: 134px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3], k = 5
<strong>输出：</strong>[[1],[2],[3],[],[]]
<strong>解释：</strong>
第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
</pre>

<p><strong>示例 2：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg"" style=""width: 600px; height: 60px;"" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5,6,7,8,9,10], k = 3
<strong>输出：</strong>[[1,2,3,4],[5,6,7],[8,9,10]]
<strong>解释：</strong>
输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>链表中节点的数目在范围 <code>[0, 1000]</code></li>
    <li><code>0 &lt;= Node.val &lt;= 1000</code></li>
    <li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
<div><div>Related Topics</div><div><li>链表</li></div></div><br><div><li>👍 249</li><li>👎 0</li></div>"	"<xmp>
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {

        int length = 0;
        ListNode cur = head;
        while (cur != null) {
            cur = cur.next;
            length++;
        }

        int n = length / k;
        int m = length % k;

        ListNode[] ans = new ListNode[k];

        int i = 1;

        cur = head;

        while (i <= k) {
            ListNode g = new ListNode(-1, cur);
            ListNode pre = null;
            int j = 1;
            while (j <= n) {
                pre = cur;
                cur = cur.next;
                j++;
            }

            if (i <= m) {
                pre = cur;
                cur = cur.next;
            }

            if (pre != null)
                pre.next = null;

            ans[i - 1] = g.next;

            i++;
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_735"	"<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的行星。</p>

<p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p>

<p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>asteroids = [5,10,-5]
<strong>输出：</strong>[5,10]
<b>解释：</b>10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>asteroids = [8,-8]
<strong>输出：</strong>[]
<b>解释：</b>8 和 -8 碰撞后，两者都发生爆炸。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>asteroids = [10,2,-5]
<strong>输出：</strong>[10]
<b>解释：</b>2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>asteroids = [-2,-1,1,2]
<strong>输出：</strong>[-2,-1,1,2]
<b>解释</b><strong>：</strong>-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>2 <= asteroids.length <= 10<sup>4</sup></code></li>
    <li><code>-1000 <= asteroids[i] <= 1000</code></li>
    <li><code>asteroids[i] != 0</code></li>
</ul>
<div><div>Related Topics</div><div><li>栈</li><li>数组</li></div></div><br><div><li>👍 218</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        return null;
    }
}
</xmp>"	"leetcode"
"leetcode_739"	"<p>请根据每日 <code>气温</code> 列表 <code>temperatures</code> ，<span style=""font-size:10.5pt""><span style=""font-family:Calibri""><span style=""font-size:10.5000pt""><span style=""font-family:宋体""><font face=""宋体"">请计算在每一天需要等几天才会有更高的温度</font></span></span></span></span>。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> <code>temperatures</code> = [73,74,75,71,69,72,76,73]
<strong>输出:</strong> [1,1,4,2,1,1,0,0]
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> temperatures = [30,40,50,60]
<strong>输出:</strong> [1,1,1,0]
</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> temperatures = [30,60,90]
<strong>输出: </strong>[1,1,0]</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= temperatures.length <= 10<sup>5</sup></code></li>
    <li><code>30 <= temperatures[i] <= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>栈</li><li>数组</li><li>单调栈</li></div></div><br><div><li>👍 1011</li><li>👎 0</li></div>"	"<xmp>class Solution {

    LinkedList<Integer> stack = new LinkedList<>();

    public int[] dailyTemperatures(int[] temperatures) {
        int length = temperatures.length;

        int[] ans = new int[length];
        int i = 0;
        while (i < length) {
            int temperature = temperatures[i];
            while (!stack.isEmpty() && temperature > temperatures[stack.peek()]) {
                Integer pre = stack.pop();
                ans[pre] = i - pre;
            }
            stack.push(i);
            i++;
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_740"	"<p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p>

<p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有 </strong>等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>

<p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,4,2]
<strong>输出：</strong>6
<strong>解释：</strong>
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,2,3,3,3,4]
<strong>输出：</strong>9
<strong>解释：</strong>
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>
    <li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>动态规划</li></div></div><br><div><li>👍 546</li><li>👎 0</li></div>"	"<xmp>class Solution {

    // 相同大小的元素相加和放入到另外一个数组中
    public int deleteAndEarn(int[] nums) {
        int max = 0;
        for (int num : nums) {
            max = Math.max(num, max);
        }

        int[] dp = new int[max + 1];
        int[] count = new int[max + 1];

        for (int num : nums) {
            count[num] = count[num] + num;
        }

        int i = 1;
        while (i <= max) {
            dp[i] = Math.max(dp[i - 1], (i < 2 ? 0 : dp[i - 2]) + count[i]);
            i++;
        }

        return dp[max];
    }
}
</xmp>"	"leetcode"
"leetcode_763"	"<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>

<p> </p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>S = ""ababcbacadefegdehijhklij""
<strong>输出：</strong>[9,7,8]
<strong>解释：</strong>
划分结果为 ""ababcbaca"", ""defegde"", ""hijhklij""。
每个字母最多出现在一个片段中。
像 ""ababcbacadefegde"", ""hijhklij"" 的划分是错误的，因为划分的片段数较少。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>
    <li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>哈希表</li><li>双指针</li><li>字符串</li></div></div><br><div><li>👍 660</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    char[] chars = null;

    public List<Integer> partitionLabels(String s) {
        List<Integer> ans = new ArrayList<>();

        length = s.length();
        chars = new char[length + 1];
        System.arraycopy(s.toCharArray(), 0, chars, 1, length);

        int i = 1, max = 1, pre = 0;
        while (i <= length) {
            int j = length;

            while (j > max) {
                if (chars[j] == chars[i]) {
                    max = j;
                    break;
                }
                j--;
            }

            if (i == max) {
                ans.add(i - pre);
                pre = i;
                max++;
            }

            i++;
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_807"	"<p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p>

<p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p>

<p>我们被允许为 <strong>任意数量的建筑物 </strong>的高度增加<strong> 任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 <code>0</code> 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p>

<p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png"" style=""width: 700px; height: 603px;"" />
<pre>
<strong>输入：</strong>grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
<strong>输出：</strong>35
<strong>解释：</strong>建筑物的高度如上图中心所示。
用红色绘制从不同方向观看得到的天际线。
在不影响天际线的情况下，增加建筑物的高度：
gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [[0,0,0],[0,0,0],[0,0,0]]
<strong>输出：</strong>0
<strong>解释：</strong>增加任何建筑物的高度都会导致天际线的变化。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == grid.length</code></li>
    <li><code>n == grid[r].length</code></li>
    <li><code>2 &lt;= n &lt;= 50</code></li>
    <li><code>0 &lt;= grid[r][c] &lt;= 100</code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>矩阵</li></div></div><br><div><li>👍 212</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int maxIncreaseKeepingSkyline(int[][] grid) {
        int ans = 0;

        int cl = grid.length;
        int rl = grid[0].length;

        int[] ch = new int[cl];
        int[] rh = new int[rl];

        for (int i = 0; i < cl; i++) {
            int max = 0;
            for (int j = 0; j < rl; j++) {
                if (grid[j][i] > max)
                    max = grid[j][i];
            }
            ch[i] = max;
        }

        for (int i = 0; i < rl; i++) {
            int max = 0;
            for (int j = 0; j < cl; j++) {
                if (grid[i][j] > max)
                    max = grid[i][j];
            }
            rh[i] = max;
        }

        for (int i = 0; i < rl; i++) {
            for (int j = 0; j < cl; j++) {
                int num = grid[i][j];
                ans += Math.min(rh[i] - num, ch[j] - num);
            }
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_881"	"<p>给定数组<meta charset=""UTF-8"" />&nbsp;<code>people</code>&nbsp;。<code>people[i]</code>表示第 <code>i</code><sup>&nbsp;</sup>个人的体重&nbsp;，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>

<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>

<p>返回 <em>承载所有人所需的最小船数</em>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>people = [1,2], limit = 3
<strong>输出：</strong>1
<strong>解释：</strong>1 艘船载 (1, 2)
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>people = [3,2,2,1], limit = 3
<strong>输出：</strong>3
<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>people = [3,5,3,4], limit = 5
<strong>输出：</strong>4
<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>
    <li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>贪心</li><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 208</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;
    int[] people = null;

    public int numRescueBoats(int[] $people, int limit) {
        Arrays.sort($people);
        length = $people.length;
        people = new int[length + 1];
        System.arraycopy($people, 0, people, 1, length);

        int left = 1, right = length, ans = 0;

        while (left <= right) {
            int weight = people[right] + people[left];
            if (weight > limit) {
                // 仅仅右指针左移
                right--;
            } else {
                left++;
                right--;
            }
            ans++;
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_904"	"<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>

<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>

<ul>
    <li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>
    <li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
    <li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>

<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>fruits = [<em><strong>1,2,1</strong></em>]
<strong>输出：</strong>3
<strong>解释：</strong>可以采摘全部 3 棵树。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>fruits = [0,<em><strong>1,2,2</strong></em>]
<strong>输出：</strong>3
<strong>解释：</strong>可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>fruits = [1,<em><strong>2,3,2,2</strong></em>]
<strong>输出：</strong>4
<strong>解释：</strong>可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>fruits = [3,3,3,<em><strong>1,2,1,1,2</strong></em>,3,3,4]
<strong>输出：</strong>5
<strong>解释：</strong>可以采摘 [1,2,1,1,2] 这五棵树。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>
    <li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>滑动窗口</li></div></div><br><div><li>👍 160</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;

    public int totalFruit(int[] fruits) {
        int ans = 0;

        length = fruits.length;
        Map<Integer, Integer> map = new HashMap<>();
        int i = 0, j = 0;

        while (j < length) {
            while (map.size() <= 2 && j < length) {
                map.put(fruits[j], map.getOrDefault(fruits[j], 0) + 1);
                j++;
            }

            ans = Math.max(ans, map.size() > 2 ? j - 1 - i : j - i);

            while (map.size() > 2) {
                int temp = map.get(fruits[i]) - 1;
                if (temp > 0) {
                    map.put(fruits[i], temp);
                } else {
                    map.remove(fruits[i]);
                }
                i++;
            }
        }

        return ans;
    }
}
</xmp>"	"leetcode"
"leetcode_912"	"<p>给你一个整数数组&nbsp;<code>nums</code>，请你将该数组升序排列。</p>

<p>&nbsp;</p>

<ol>
</ol>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [5,2,3,1]
<strong>输出：</strong>[1,2,3,5]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [5,1,1,2,0,0]
<strong>输出：</strong>[0,0,1,1,2,5]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
    <li><code>-5 * 10<sup>4</sup> &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>分治</li><li>桶排序</li><li>计数排序</li><li>基数排序</li><li>排序</li><li>堆（优先队列）</li><li>归并排序</li></div></div><br><div><li>👍 470</li><li>👎 0</li></div>"	"<xmp>class Solution {
    int length = 0;
    int[] nums = null;

    int left = 0, right = 0, mid = 0;
    LinkedList<int[]> cs = new LinkedList<>();
    LinkedList<int[]> ss = new LinkedList<>();

    public int[] sortArray(int[] $nums) {
        length = $nums.length;
        left = 1;
        right = length;
        nums = new int[length + 1];
        System.arraycopy($nums, 0, nums, 1, length);

        push();
        while (!cs.isEmpty()) {
            int[] c = cs.peek();
            if (ss.peek() != c) {
                ss.push(c);
                left = c[0];
                right = c[1];
                mid = c[2];
                push();
            } else {
                ss.pop();
                cs.pop();
            }
        }

        System.arraycopy(nums, 1, $nums, 0, length);
        return $nums;
    }

    void push() {
        if (left > right)
            return;
        int l = left, r = right, pivot = nums[left];
        while (l <= r) {
            while (l <= r && nums[l] <= pivot)
                l++;
            while (l <= r && nums[r] > pivot)
                r--;
            if (l <= r) {
                swap(l, r);
            }
        }
        mid = l - 1;
        swap(mid, left);
        cs.push(new int[] { left, mid - 1, mid });
        cs.push(new int[] { mid + 1, right, mid });
    }

    void swap(int a, int b) {
        nums[0] = nums[a];
        nums[a] = nums[b];
        nums[b] = nums[0];
    }
}
</xmp>"	"leetcode"
"leetcode_974"	"<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code>&nbsp;整除的（连续、非空） <strong>子数组</strong> 的数目。</p>

<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [4,5,0,-2,-3,1], k = 5
<strong>输出：</strong>7
<strong>解释：
</strong>有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> nums = [5], k = 9
<strong>输出:</strong> 0
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
    <li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
    <li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>前缀和</li></div></div><br><div><li>👍 343</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);

        int count = 0;
        int pre = 0;

        for (int num : nums) {
            pre = pre + num;

            // 如果 pre % k 小于 0, 就加上k 再取余数
            int mod = (pre % k + k) % k;

            if (map.containsKey(mod)) {
                count += map.get(mod);
            }

            map.put(mod, map.getOrDefault(mod, 0) + 1);
        }

        return count;
    }
}
</xmp>"	"leetcode"
"leetcode_1048"	"<p>给出一个单词数组&nbsp;<code>words</code>&nbsp;，其中每个单词都由小写英文字母组成。</p>

<p>如果我们可以&nbsp;<strong>不改变其他字符的顺序&nbsp;</strong>，在 <code>word<sub>A</sub></code>&nbsp;的任何地方添加 <strong>恰好一个</strong> 字母使其变成&nbsp;<code>word<sub>B</sub></code>&nbsp;，那么我们认为&nbsp;<code>word<sub>A</sub></code>&nbsp;是&nbsp;<code>word<sub>B</sub></code>&nbsp;的 <strong>前身</strong> 。</p>

<ul>
    <li>例如，<code>""abc""</code>&nbsp;是&nbsp;<code>""abac""</code>&nbsp;的 <strong>前身</strong>&nbsp;，而&nbsp;<code>""cba""</code>&nbsp;不是&nbsp;<code>""bcad""</code>&nbsp;的 <strong>前身</strong></li>
</ul>

<p><strong>词链</strong>是单词&nbsp;<code>[word_1, word_2, ..., word_k]</code>&nbsp;组成的序列，<code>k &gt;= 1</code>，其中&nbsp;<code>word<sub>1</sub></code>&nbsp;是&nbsp;<code>word<sub>2</sub></code>&nbsp;的前身，<code>word<sub>2</sub></code>&nbsp;是&nbsp;<code>word<sub>3</sub></code>&nbsp;的前身，依此类推。一个单词通常是 <code>k == 1</code> 的 <strong>单词链</strong>&nbsp;。</p>

<p>从给定单词列表 <code>words</code> 中选择单词组成词链，返回 词链的&nbsp;<strong>最长可能长度</strong> 。<br />
&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>words = [""a"",""b"",""ba"",""bca"",""bda"",""bdca""]
<strong>输出：</strong>4
<strong>解释：</strong>最长单词链之一为 [""a"",""<u>b</u>a"",""b<u>d</u>a"",""bd<u>c</u>a""]
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<b>输入：</b>words = [""xbc"",""pcxbcf"",""xb"",""cxbc"",""pcxbc""]
<b>输出：</b>5
<b>解释：</b>所有的单词都可以放入单词链 [""xb"", ""xb<u>c</u>"", ""<u>c</u>xbc"", ""<u>p</u>cxbc"", ""pcxbc<u>f</u>""].
</pre>

<p><strong>示例&nbsp;3:</strong></p>

<pre>
<b>输入：</b>words = [""abcd"",""dbqca""]
<strong>输出：</strong>1
<b>解释：</b>字链[""abcd""]是最长的字链之一。
[""abcd""，""dbqca""]不是一个有效的单词链，因为字母的顺序被改变了。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= words.length &lt;= 1000</code></li>
    <li><code>1 &lt;= words[i].length &lt;= 16</code></li>
    <li><code>words[i]</code>&nbsp;仅由小写英文字母组成。</li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>双指针</li><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 160</li><li>👎 0</li></div>"	"<xmp>class Solution {

    int length = 0;

    public int longestStrChain(String[] words) {
        int ans = 0;
        Arrays.sort(words, Comparator.comparingInt(String::length));

        length = words.length;
        int[] dp = new int[length];
        int i = 0;
        while (i < length) {
            int j = i - 1;
            int max = 0;
            while (j >= 0) {
                if (words[j].length() >= words[i].length()) {

                } else if (words[j].length() == words[i].length() - 1) {
                    if (isMatch(words[i], words[j])) {
                        max = Math.max(dp[j] + 1, max);
                    }
                } else {
                    break;
                }
                j--;
            }
            dp[i] = Math.max(1, max);
            ans = Math.max(dp[i], ans);
            i++;
        }

        return ans;

    }

    boolean isMatch(String str1, String str2) {
        int i = 0, j = 0;
        while (i < str1.length() && j < str2.length()) {
            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }
            i++;
        }

        if (j != str2.length()) {
            return false;
        } else {
            return true;
        }
    }
}
</xmp>"	"leetcode"
"leetcode_1094"	"<p>假设你是一位顺风车司机，车上最初有&nbsp;<code>capacity</code>&nbsp;个空座位可以用来载客。由于道路的限制，车&nbsp;<strong>只能&nbsp;</strong>向一个方向行驶（也就是说，<strong>不允许掉头或改变方向</strong>，你可以将其想象为一个向量）。</p>

<p>这儿有一份乘客行程计划表&nbsp;<code>trips[][]</code>，其中&nbsp;<code>trips[i] = [num_passengers, start_location, end_location]</code>&nbsp;包含了第 <code>i</code> 组乘客的行程信息：</p>

<ul>
    <li>必须接送的乘客数量；</li>
    <li>乘客的上车地点；</li>
    <li>以及乘客的下车地点。</li>
</ul>

<p>这些给出的地点位置是从你的&nbsp;<strong>初始&nbsp;</strong>出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。</p>

<p>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回&nbsp;<code>true</code>，否则请返回 <code>false</code>）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 4
<strong>输出：</strong>false
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 5
<strong>输出：</strong>true
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>trips = [[2,1,5],[3,5,7]], capacity = 3
<strong>输出：</strong>true
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11
<strong>输出：</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>你可以假设乘客会自觉遵守 &ldquo;<strong>先下后上</strong>&rdquo; 的良好素质</li>
    <li><code>trips.length &lt;= 1000</code></li>
    <li><code>trips[i].length == 3</code></li>
    <li><code>1 &lt;= trips[i][0] &lt;= 100</code></li>
    <li><code>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</code></li>
    <li><code>1 &lt;=&nbsp;capacity &lt;= 100000</code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>前缀和</li><li>排序</li><li>模拟</li><li>堆（优先队列）</li></div></div><br><div><li>👍 148</li><li>👎 0</li></div>"	"<xmp>class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        return false;
    }
}
</xmp>"	"leetcode"
"leetcode_1143"	"<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>

<p>一个字符串的 <strong>子序列</strong><em> </em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>

<ul>
    <li>例如，<code>""ace""</code> 是 <code>""abcde""</code> 的子序列，但 <code>""aec""</code> 不是 <code>""abcde""</code> 的子序列。</li>
</ul>

<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>text1 = ""abcde"", text2 = ""ace"" 
<strong>输出：</strong>3  
<strong>解释：</strong>最长公共子序列是 ""ace"" ，它的长度为 3 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>text1 = ""abc"", text2 = ""abc""
<strong>输出：</strong>3
<strong>解释：</strong>最长公共子序列是 ""abc"" ，它的长度为 3 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>text1 = ""abc"", text2 = ""def""
<strong>输出：</strong>0
<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= text1.length, text2.length <= 1000</code></li>
    <li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li></div></div><br><div><li>👍 834</li><li>👎 0</li></div>"	"<xmp></xmp>"	"leetcode"
"leetcode_1218"	"<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>

<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>arr = [1,2,3,4], difference = 1
<strong>输出：</strong>4
<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>arr = [1,3,5,7], difference = 1
<strong>输出：</strong>1
<strong>解释：</strong>最长的等差子序列是任意单个元素。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2
<strong>输出：</strong>4
<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= arr.length <= 10<sup>5</sup></code></li>
    <li><code>-10<sup>4</sup> <= arr[i], difference <= 10<sup>4</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>动态规划</li></div></div><br><div><li>👍 205</li><li>👎 0</li></div>"	"<xmp>class Solution {

    public int longestSubsequence(int[] arr, int difference) {
        int ans = 0;
        Map<Integer, Integer> dp = new HashMap<Integer, Integer>();
        for (int v : arr) {
            dp.put(v, dp.getOrDefault(v - difference, 0) + 1);
            ans = Math.max(ans, dp.get(v));
        }
        return ans;
    }
}
</xmp>"	"leetcode"
